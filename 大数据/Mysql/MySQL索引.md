## **mysql索引**

### **索引选择数据结构的考虑**
索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以**评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度**。换句话说，**索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数**。

### **局部性原理与磁盘预读**
由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一，因此为了提高效率，要尽量减少磁盘I/O。

为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会**预读**，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。

这样做的理论依据是计算机科学中著名的局部性原理：
当一个数据被用到时，其附近的数据也通常会马上被使用。

程序运行期间所需要的数据通常比较集中。
由于**磁盘顺序读取的效率很高**（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。

**预读的长度一般为页（page）的整倍数**。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），**主存和磁盘以页为单位交换数据**。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，**磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中**，然后异常返回，程序继续运行

### **索引使用的底层数据结构**
#### **B树(B-tree)**
注意:之前有看到有很多文章把B树和B-tree理解成了两种不同类别的树，其实这两个是同一种树
* 概念：
B树和平衡二叉树稍有不同的是**B树属于多叉树又名多路平衡查找树**（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构，让我们来看看他有什么特点。
* 规则：
  1. 排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
  2. 子节点数：非叶节点的子节点数>1，且<=M ，且M>=2，空树除外（注：**M阶代表一个树节点最多有多少个查找路径**，M=M路,当M=2则是2叉树,M=3则是3叉）；
  3. 关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);
  4. 所有叶子节点均在同一层，叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针，只不过其指针地址都为null，对应下图最后一层节点的空格子;

最后我们用一个图和一个实际的例子来理解B树

![B-tree](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E5%A4%A7%E6%95%B0%E6%8D%AE/resources/B-tree.png)

因为索引数据存储在磁盘上，数据读取的时候需要从磁盘读取到内存，但内存读取的效率远高于磁盘读取，因此内存与外存（比如磁盘）交换数据越频繁，会导致效率越低。

磁盘读取数据的时候，是将磁盘分割为大小相等的页（page），页是数据读取的单元，每次磁盘读写都是一个或多个完整的页。

在一个典型的B树应用中（比如索引），要处理的磁盘数据很大，无法一次载入内存，因此我们会对B树进行调整，使得B树的阶数（或节点的元素）与硬盘存储的页面大小相匹配。比如说一棵B树的阶为1001（即1个节点包含1000个关键字），高度为2，它可以储存超过10亿个关键字，我们只要让根结点持久地保留在内存中，那么在这棵树上，寻找某一个关键字至多需要两次硬盘的读取即可。

#### **B树的缺陷**
在B树结构中，我们往返于每个节点之间也就意味着，我们必须得在硬盘的页面之间进行多次访问，如上图所示，我们希望遍历这棵B树，假设每个节点都属于硬盘的不同页面，我们为了中序遍历所有的元素，页面2→页面1→页面3→页面1→页面4→页面1→页面5。而且我们每次经过节点遍历时，都会对节点中的元素进行一次遍历

#### **B+树**
B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定，我们先看看两者的区别

#### **B+树规则**
1. B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；
2. B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的IO次数都一样；
3. B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。
4. 非叶子节点的**子节点数=关键字数**（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的,Mysql 的B+树是用第一种方式实现）;

B+树的结构示意图如下：

![B-plus-tree](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E5%A4%A7%E6%95%B0%E6%8D%AE/resources/B-plus-tree.jpg)

一棵m阶的B+树和m阶的B树的差异在于（节点最大的子节点数目称为B树的阶order）：
* B+树中有n棵子树的节点中包含有n个关键字，而B树中有n棵子树的节点包含n-1个关键字；
* B+树非叶子节点不保存数据，只用来索引，而B树非叶子节点也包含数据；
* B+树所有的叶子节点包含全部关键字的信息及指向含这些关键字记录的指针（数据），叶子节点本身依关键字的大小自小而大顺序链接，而B树的查找所有关键字需要遍历整棵树；
* B+树所有分支节点可以看成是索引，节点中仅含有其子树中的最大（或最小）关键字，而B树的所有分支节点还包含数据，且子树中不包含分支节点的关键字；

因此，B+树用作索引，相比B树的优势是：
* 因为在 B+ 树中非叶子节点上是不存储数据的仅存储键值，而**数据库中页的大小是固定的，InnoDB 中页的默认大小是 16 KB，如果不存储数据，那么节点就可以存储更多的键值，相应的树的阶数就会更大，对于同样的数据量来说，需要的树高就会变低，树会更矮胖，如此一来查找数据的时候进行磁盘的 IO 次数就会减少，提升查询效率**。由于 B+ 树的阶数等于键值数量，假设 B+ 树的一个节点可以存储 1000 个键值，那么 3 层的 B+ 树 可以存储 1000 x 1000 x 1000 = 10亿个数据。并且一般根节点是常驻内存的，所以查找 10 亿个数据，只需要 2 次磁盘 IO；
* B+ 树的叶子节点中的索引数据是按顺序排列的，并且叶子节点间是通过双向链表（单向链表？）进行连接的。这个特点使 **B+ 树在实现范围查找，排序查找，分组查找等操作时变得异常简单**。而 B 树由于数据分散在各个节点，要实现这些操作很不容易；
* B+ 树查询效率更加稳定。 B+ 树中任何关键字的随机查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。而对于 B 树来说，因为其每个节点都存具体的数据，因此其查询速度可能更快，但是却并不稳定；

建议用自增主键作为聚簇索引，即按顺序生成并插入主键，否则可能会导致页分裂形成很多页碎片

#### **B+Tree结构都可以用在MyISAM和InnoDB上**
MyISAM使用的是非聚簇索引，B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主键索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。这里的索引都是非聚簇索引。非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方。

这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。InnoDB的数据文件本身就是索引文件，B+Tree的叶子节点上的data就是数据本身，key为主键，这是聚簇索引。

InnoDB使用的是聚簇索引（有且只能有必须有一个）+非聚簇索引（其他索引，可有可无），将主键（默认是聚簇索引）组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据

### **唯一索引与非唯一索引的区别**
唯一索引比如主键索引、唯一约束字段的索引
非唯一索引比如非主键或唯一约束字段的索引

对于 B+ 树而言，叶子节点的数据是有序的。

### **普通索引的检索过程**
假设现在我们要查询 2 这条数据，那么在通过索引树找到 2 的时候，存储引擎并没有停止搜索。因为可能存在多个 2，这表现为存储引擎会在叶子节点上接着向后查找。在找到第二个2之后，就停止了吗？答案是“否”，因为存储引擎并不知道后面还有没有更多的2，所以得接着向后查找，直至找到第一个不是2的数据，也就是3。找到3之后，停止检索，这就是普通索引的检索过程。

### **唯一索引的检索过程**
唯一索引就不一样了，因为唯一性，不可能存在重复的数据。所以，在检索到我们的目标数据之后直接返回，不会像普通索引那样还要向后多查找一次。从这个角度来看，唯一索引是要比普通索引快的。但是当普通索引的数据都在一个页内的话，其实也并不会快多少。

在数据的插入方面，唯一索引可能就稍逊色。因为唯一性，每次插入的时候，都需要将判断要插入的数据是否已经存在，而普通索引不需要这个逻辑，并且很重要的一点是唯一索引会用不到 change buffer

Change buffer
我们知道在更新一条数据的时候，要先判断这条数据的页是否在内存里。
如果在内存中的话，直接更新对应的内存页；如果不在的话，只能去磁盘把对应的数据页读到内存中来，然后再更新。
这会有什么问题呢？
1. 去磁盘的读这个动作稍显的有点慢；
2. 如果同时更新很多数据，那么即有可能发生很多离散的 IO。
为了解决这种情况下的速度问题，change buffer 出现了。
首先，不要被 buffer 这个单词误导。change buffer 除了会在公共的 buffer pool 里之外，也是会持久化到磁盘的。
当有了 change buffer 之后，我们更新的过程中，如果发现对应的数据页不在内存里的话，也不去磁盘读取相应的数据页了，而是把要更新的数据放入到 change buffer 中。
那 change buffer 的数据何时被同步到磁盘上去？如果此时发生读动作怎么办？
首先，后台有个线程会定期把 change buffer 的数据同步到磁盘上去的。如果线程还没来得及同步，但是又发生了读操作，那么也会触发把 change buffer 的数据 merge 到磁盘的事件。

需要注意的是，并不是所有的索引都能用到 changer buffer。像主键索引和唯一索引就用不到。
因为唯一性，所以它们在更新的时候要判断数据存不存在。如果数据页不在内存中，就必须去磁盘上把对应的数据页读到内存里，而普通索引就没关系了，不需要校验唯一性。change buffer 越大，理论收益就越大，这是因为首先离散的读 IO 变少了。
其次，当一个数据页上发生多次变更，只需 merge 一次到磁盘上。
当然并不是所有的场景都适合 change buffer。如果你的业务是更新之后，需要立马去读，change buffer 会适得其反。
因为需要不停地触发 merge 动作，导致随机 IO 的次数不会变少，反而增加了维护 change buffer 的开销。


索引下推
能减少二级索引的回表查询次数，也能减少查询引擎和Mysql Server层之间的数据传递量

前面我们说了联合索引，联合索引要满足最左原则，即在联合索引是 [A,B] 的情况下，我们可以通过以下的 SQL 用到索引：
select * from table where A="xx"select * from table where A="xx" AND B="xx"
其实联合索引也可以使用最左前缀的原则，即：
select * from table where A like "赵%" AND B="上海市"
但是这里需要注意的是，因为使用了 A 的一部分，在 MySQL 5.6 之前，上面的 SQL 在检索出所有 A 是“赵”开头的数据之后，就立马回表（使用的 select *）。然后，再对比 B 是不是“上海市”这个判断。
这里是不是有点懵？为什么 B 这个判断不直接在联合索引上判断，这样的话回表的次数不就少了吗？
造成这个问题的原因还是因为使用了最左前缀的问题。导致索引虽然能使用部分 A，但是完全用不到 B，看起来是有点“傻”。
于是在 MySQL5.6 之后，就出现了索引下推这个优化（Index Condition Pushdown）。有了这个功能以后，虽然使用的是最左前缀，但是也可以在联合索引上搜索出符合 A% 的同时也过滤非 B 的数据，大大减少了回表的次数。

MRR（Multi-Range Read）
在实际业务中，我们可能会被告知尽量使用覆盖索引，不要回表。因为回表需要更多 IO，耗时更长。但是有时候我们又不得不回表，回表不仅仅会造成过多的 IO，更严重的是过多的离散 IO。
select * from user where grade between 60 and 70
现在要查询成绩在 60-70 之间的用户信息，于是我们的 SQL 写成上面的那样。当然，我们的 grade 字段是有索引的。
按照常理来说，会先在 grade 索引上找到 grade=60 这条数据，然后再根据 grade=60 这条数据对应的 id 去主键索引上找，最后再次回到 grade 索引上，不停重复同样的动作……
假设现在：
* grade=60 对应的 id=1，数据是在 page_no_1 上；
* grade=61 对应的 id=10，数据是在 page_no_2 上；
* grade=62 对应的 id=2，数据是在 page_no_1上。
所以，真实的情况就是先在 page_no_1 上找数据，然后切到 page_no_2，最后又切回 page_no_1 上。
但其实 id=1 和 id=2 完全可以合并，读一次 page_no_1 即可。不仅节省了 IO，同时避免了随机 IO，这就是 MRR。
当使用 MRR 之后，辅助索引不会立即去回表，而是将得到的主键 id，放在一个 buffer中。然后再对其排序，排序后再去顺序读主键索引，大大减少了离散的 IO。



如何优化查询效率？

查看Sql执行计划
explain select语句查看索引的使用情况
Possible key：可能用到的索引
Key：实际用到的索引
key_len：索引的长度
Type：扫描类型

按执行效率由高到底的扫描类型为
Const（结果只有一条的主键或唯一索引扫描）
eq_ref（唯一索引扫描）
ref（非唯一索引扫描）
range（索引范围扫描）
Index（全索引扫描）
All（全表扫描）

Long_query_time参数设置慢查询的时间，比如1秒
那么大于等于1秒的sql就会被记录进慢查询日志

索引的分类
数据结构：B+树、Hash、Full-text
物理存储：聚簇索引、二级索引（辅助索引）
字段特型：主键索引、唯一索引、普通索引（非主键或唯一字段上建立的索引）、前缀索引（对字符串类型的前几个字符或对二进制类型字段的前几个bytes建立的索引，而不是在整个字段上建索引）
字段个数：单列索引、联合索引（复合索引）

Hash索引能以O(1)时间进行查找，但失去了有序性，更适合做等值精确查询（如=，in），不适合做范围查询，无法用于排序和分组，且存在hash函数选择和hash冲突的问题，因此B+树索引要比hash索引有更广泛的适用场景

InnoDB存储引擎中的B+树索引
聚簇索引：全表数据存储在聚簇索引，每个叶子节点存储了一行完整的表数据，叶子节点间采用单向链表按id列递增链接，可以方便的进行顺序检索。Innodb表要求必须有聚簇索引，默认在主键字段上建立聚簇索引，在没有主键的情况下，表的第一个Not null的唯一索引字段将被建为聚簇索引。在前两者都没有的情况下，Innodb将自动生成一个隐式自增id列并在此列上创建聚簇索引

聚簇索引之外的所有索引称为二级索引
二级索引的叶子节点并不存储一行完整的数据，而是存储了聚簇索引所在列的值

回表查询
由于二级索引的叶子节点并不存储完整的表数据，所以当通过二级索引查询到聚簇索引列的值后，还需要回到聚簇索引也就是表数据本身进一步获取数据。回表需要额外的B+树搜索过程，必然增大查询耗时。不是所有的二级索引查询都需要回表，当query的所有字段在二级索引中就能找到的时候，就不需要回表，Mysql称此时的二级索引为覆盖索引或称触发了索引覆盖

索引下推机制
能减少二级索引的回表查询次数，也能减少查询引擎和Mysql Server层之间的数据传递量

覆盖索引
所谓覆盖索引，二级索引的一种，是指sql中query的所有字段，在索引B+树的叶子节点上都能找到的那些索引

MyIsam存储引擎中的B+树索引
不存在聚簇索引，其主键索引和非主键索引的结构是一样的，其叶子节点是不存储表数据的，存放的是表数据的地址，MyIsam的数据和索引是分开的，是分别单独存放的

联合索引的B+树结构
联合索引的B+树的非叶子节点保存了联合索引中所有字段的值
最左匹配准则（遇到范围查询(>、<、between、like)就会停止匹配）
尽量把区分度大的字段放在前面
区分度：某个字段不同值的个数占表的总行数的比值
比如性别这种字段区分度就很小， 不适合建立索引或不适合放在联合索引的靠前的位置，相反像uuid这样的字段，就适合做索引或放在联合索引靠前的位置

索引失效的5种情况
1.被索引字段发生了隐式类型转换；
2.被索引字段使用了表达式计算；
3.被索引字段使用了函数；
4.like关键字后使用了左模糊匹配或者左右模糊匹配；
5.使用的被索引字段，不是联合索引的最左字段；

123为什么会导致索引失效？
因为索引的使用是依赖于整个B+树的遍历，而索引树的遍历依赖于索引树底层叶子节点的有序性，当被索引字段进行了隐式类型转换、表达式计算或者函数计算后，有可能这个字段新的排列顺序和原来在索引树的叶子节点层的排列顺序不一样了，这就破坏了索引树叶子节点的有序性

即使使用了索引但可能查询效率也不高，比如
1.需扫描整个索引，并回表
2.部分索引扫描并回表，代价高于全表扫描
可以通过force index强制走某个索引

如何建立高效的索引？
1.前缀索引
2.索引覆盖
3.联合索引最左匹配准则
4.索引字段的区分度

索引的缺点
1.索引会带来数据写入的延迟
2.索引会引入额外的空间存储
3.索引能提升查询效率的场景是有限的，大数据量时需要其他的如读写分离，分库分表等方案