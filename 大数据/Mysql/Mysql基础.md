## **mysql的逻辑架构**

![mysql-logic-arch]()

大致上，mysql可以分为server层和存储引擎层两层
- **Server层**：包括连接器、查询缓存、分析器、优化器、执行器等，涵盖了mysql的大多数核心服务功能，以及所有的内置函数，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等；
- **存储引擎层**：数据的存取和提取，其架构是插件式的，支持InnoDB、MyIsam等多种存储引擎，从mysql5.5.5版本开始默认存储引擎是InnoDB，可以在建表的时候通过engine=MyIsam来指定存储引擎

## **一条SQL语句的执行过程**

![mysql-sql-exec-proc]()

- **处理连接**：第一步，要首先连接上数据库，这个时候使用的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接；

- **查询缓存**：连接建立完成后，就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果都会以key-value 对的形式，被直接缓存到内存中。其中，key 是查询的语句，value 是查询的结果。如果你的查询能够直接在缓存中找到 key，那么这个 value 就会直接返回给客户端。 但**查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空**。因此很可能你刚费劲存的结果还没来得及使用就被一个更新给清空了。**对于更新压力大的数据库而言，查询缓存的命中率就会非常低**；

- **词法和语法分析**：如果没有命中查询缓存，就要开始正真执行语句了。首先，MySQL 需要知道你要做什么，因此要对 SQL 语句做解析。分析器先会做“词法分析”。MySQL 从你输入的"select"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。做完了这些识别以后，就要做“语法分析”。语法分析根据语法规则，判断输入的这个 SQL语句是否满足 MySQL 的语法规范。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒；

- **优化分析和生成执行计划**：经过了分析器，MySQL就知道你要做什么了，在开始之前还要经过优化器的处理。**优化器是在表里有多个索引的时候，决定使用哪个索引，或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序**；

- **执行**：MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入执行器阶段，开始执行语句；

## **Varchar(100) vs Varchar(200)的区别**
假如他们用来存储90个字符的数据，其存储空间相同，但是**对于内存的消耗是不同的**。

对于VARCHAR数据类型来说，**硬盘上的存储空间虽然都是根据实际字符长度来分配存储空间的**，但是**对于内存来说则其是使用固定大小的内存块来保存值**。

简单的说，就是使用字符类型中定义的长度，即200个字符空间。显然，这对于排序或者临时表（这些内容都需要通过内存来实现）作业会产生比较大的不利影响。
假设VARCHAR(100)与VARCHAR(200)类型，实际存90个字符，它不会对存储端产生影响（就是实际占用硬盘是一样的）。但是，它**确实会对查询产生影响**，因为当MySql 创建临时表(SORT，ORDER等)时，VARCHAR会转换为CHAR，转换后的CHAR的长度就是varchar的长度，在内存中的空间就变大了，在排序、统计时候需要扫描的就越多，时间就越久。

所以如果某些字段会涉及到文件排序或者基于磁盘的临时表时，分配VARCHAR数据类型时仍然不能够太过于慷慨。还是要评估实际需要的长度，然后选择一个最长的字段来设置字符长度。如果为了考虑冗余，可以留10%左右的字符长度。千万不能认为其为根据实际长度来分配存储空间，而随意的分配长度，或者说干脆使用最大的字符长度