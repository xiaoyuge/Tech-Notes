## **mysql的逻辑架构**

![mysql-logic-arch](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E5%A4%A7%E6%95%B0%E6%8D%AE/resources/mysql-logic-arch.png)

大致上，mysql可以分为server层和存储引擎层两层

- **Server层**：包括连接器、查询缓存、分析器、优化器、执行器等，涵盖了mysql的大多数核心服务功能，以及所有的内置函数，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等；
- **存储引擎层**：数据的存取和提取，其架构是插件式的，支持InnoDB、MyIsam等多种存储引擎，从mysql5.5.5版本开始默认存储引擎是InnoDB，可以在建表的时候通过engine=MyIsam来指定存储引擎

## **一条SQL语句的执行过程**

![mysql-sql-exec-proc](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E5%A4%A7%E6%95%B0%E6%8D%AE/resources/mysql-sql-exec-proc.png)

- **处理连接**：第一步，要首先连接上数据库，这个时候使用的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接；

- **查询缓存**：连接建立完成后，就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果都会以key-value 对的形式，被直接缓存到内存中。其中，key 是查询的语句，value 是查询的结果。如果你的查询能够直接在缓存中找到 key，那么这个 value 就会直接返回给客户端。 但**查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空**。因此很可能你刚费劲存的结果还没来得及使用就被一个更新给清空了。**对于更新压力大的数据库而言，查询缓存的命中率就会非常低**；

- **词法和语法分析**：如果没有命中查询缓存，就要开始正真执行语句了。首先，MySQL 需要知道你要做什么，因此要对 SQL 语句做解析。分析器先会做“词法分析”。MySQL 从你输入的"select"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。做完了这些识别以后，就要做“语法分析”。语法分析根据语法规则，判断输入的这个 SQL语句是否满足 MySQL 的语法规范。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒；

- **优化分析和生成执行计划**：经过了分析器，MySQL就知道你要做什么了，在开始之前还要经过优化器的处理。**优化器是在表里有多个索引的时候，决定使用哪个索引，或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序**；

- **执行**：MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入执行器阶段，开始执行语句；

## **Varchar(100) vs Varchar(200)的区别**

假如他们用来存储90个字符的数据，其存储空间相同，但是**对于内存的消耗是不同的**。

对于VARCHAR数据类型来说，**硬盘上的存储空间虽然都是根据实际字符长度来分配存储空间的**，但是**对于内存来说则其是使用固定大小的内存块来保存值**。

简单的说，就是使用字符类型中定义的长度，即200个字符空间。显然，这对于排序或者临时表（这些内容都需要通过内存来实现）作业会产生比较大的不利影响。
假设VARCHAR(100)与VARCHAR(200)类型，实际存90个字符，它不会对存储端产生影响（就是实际占用硬盘是一样的）。但是，它**确实会对查询产生影响**，因为当MySql 创建临时表(SORT，ORDER等)时，VARCHAR会转换为CHAR，转换后的CHAR的长度就是varchar的长度，在内存中的空间就变大了，在排序、统计时候需要扫描的就越多，时间就越久。

所以**如果某些字段会涉及到文件排序或者基于磁盘的临时表时，分配VARCHAR数据类型时仍然不能够太过于慷慨**。还是要评估实际需要的长度，然后选择一个最长的字段来设置字符长度。如果为了考虑冗余，可以留10%左右的字符长度。千万不能认为其为根据实际长度来分配存储空间，而随意的分配长度，或者说干脆使用最大的字符长度

## **Mysql主从同步**

从MySQL5.5开始，MySQL支持半同步复制、同步复制和异步复制三种模式

mysql的主从同步是基于Binlog的，Binlog用于记录数据库执行的写入性操作（不包括查询）信息，以二进制的形式保存在磁盘中。binlog是MySQL的逻辑日志，并且**由Server层进行记录，使用任何存储引擎的MySQL数据库都会记录binlog日志**。

- **逻辑日志**：可以简单理解为记录的就是SQL语句

- **物理日志**：因为MySQL数据最终是保存在数据页中的，物理日志记录的就是数据页变更

- **binlog写入**：binlog是通过追加的方式进行写入的，可以通过max_binlog_size参数设置每个binlog文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志

- **binlog刷盘时机**：对于InnoDB存储引擎而言，只有在事务提交时才会记录biglog，此时记录还在内存中，那么biglog是什么时候刷到磁盘中的呢？MySQL通过sync_binlog参数控制biglog的刷盘时机，取值范围是0-N：
  - 0：不去强制要求，由系统自行判断何时写入磁盘；
  - 1：每次commit的时候都要将binlog写入磁盘；
  - N：每N个事务，才会将binlog写入磁盘;

从上面可以看出，**sync_binlog最安全的是设置是1，这也是MySQL 5.7.7之后版本的默认值**。但是设置一个大一些的值可以提升数据库性能，因此实际情况下也可以将值适当调大，牺牲一定的一致性来获取更好的性能

1）**异步复制（Asynchronous replication）**
**MySQL默认的复制即是异步的**，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收binlog并完成处理，这样就会有一个问题，主库如果crash掉了，此时主库上已经提交的事务可能并没有同步到从库上，如果此时，强行将从提升为主，可能导致新主库上的数据不完整，出现数据不一致的问题，但这种方式性能最好

![Mysql-Asynchronous-replication](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E5%A4%A7%E6%95%B0%E6%8D%AE/resources/Mysql-Asynchronous-replication.jpg)

2）**全同步复制（Fully synchronous replication）**
指当主库执行完一个事务，**所有的从库都执行了该事务才返回给客户端**。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的**性能很差**，另外**可用性也很差**，主库和所有从库任何一个数据库出问题，都会影响业务。所以这个方案基本没法使用。

3）**半同步复制（Semisynchronous replication）**
介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是**等待至少一个从库接收到并写到relay log中才返回给客户端**。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。

存储系统中的数据称为状态（也就是 MySQL 中的数据），状态的全量备份称为快照（Snapshot），就像给数据拍个照片一样。我们按照顺序记录更新存储系统的每条操作命令，就是操作日志（Commit Log，也就是 MySQL 中的 Binlog）

![Mysql-snapshot-commitlog](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E5%A4%A7%E6%95%B0%E6%8D%AE/resources/Mysql-snapshot-commitlog.jpg)

复制数据的时候，只要基于一个快照，按照顺序执行快照之后的所有操作日志，就可以得到一个完全一样的状态。在从节点持续地从主节点上复制操作日志并执行，就可以让从节点上的状态数据和主节点保持同步。

主从同步做数据复制时，一般可以采用几种复制策略:

- 性能最好的方法是异步复制，主节点上先记录操作日志，再更新状态数据，然后异步把操作日志复制到所有从节点上，并在从节点执行操作日志，得到和主节点相同的状态数据。异步复制的劣势是，可能存在主从延迟，如果主节点宕机，可能会丢数据。
- 另外一种常用的策略是半同步复制，主节点等待操作日志最少成功复制到 N 个从节点上之后，再更新状态，这种方式在性能、高可用和数据可靠性几个方面都比较平衡，很多分布式存储系统默认采用的都是这种方式。

### **Mysql主从复制涉及三个线程**

1. **binlog线程**：负责将主服务器上的数据更改写入二进制日志（binlog）中；
2. **I/O线程**：负责从主服务器上读取二进制日志，并写入从服务器的重放日志（relay log）中；
3. **sql线程**：负责读取重放日志并重放其中的语句；

![Mysql-replication-thread](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E5%A4%A7%E6%95%B0%E6%8D%AE/resources/Mysql-replication-thread.jpg)

### **主从同步延迟问题的解决**

Mysql的主从同步是单线程的，即使一个数据库实例有多个逻辑数据库，也是单个线程写 binlog ，每个从库单个线程拉取写 relay log 并处理
所以解决思路是变单线程为多线程

1) 每个逻辑库一个线程；
2) 如果只有一个逻辑库如何处理：可以优先考虑拆分表到不同的逻辑库，如果不好拆或不能拆，那可以考虑**每个当前并行处理的事务一个线程**进行处理；

不能随意多线程进行处理的原因：不能保证从库的处理时序跟主库一样的话 可能会导致数据不一致
比如三条update操作，分别设置同一条记录的同一个字段为不同的值

### **阿里开源的 canal**

主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费,可以简单地把canal理解为一个用来同步增量数据的一个工具

canal的工作原理就是**把自己伪装成MySQL slave**，模拟MySQL slave的交互协议向MySQL Mater发送 dump协议，MySQL mater收到canal发送过来的dump请求，开始推送binary log给canal，然后canal解析binary log，再发送到存储目的地，比如MySQL，Kafka，Elastic Search等

canal的数据同步不是全量的，而是增量。基于binary log增量订阅和消费，canal可以做：

1. 数据库镜像
2. 数据库实时备份
3. 索引构建和实时维护
4. 业务cache(缓存)刷新
5. 带业务逻辑的增量数据处理

PS：目前canal只能支持row模式的增量订阅(statement只有sql，没有数据，所以无法获取原始的变更日志)
