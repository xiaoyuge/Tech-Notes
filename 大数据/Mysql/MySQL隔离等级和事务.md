## **事务**

### **事务的 ACID 特性：**

- Atomic（原子性）
- Consistency（一致性）
- Isolation（隔离性）
- Duration（持久性）

### **事务的隔离等级：**

1. 未提交读（Read Uncommited）：一个事务在执行过程中可以看到其他事务没有提交的新记录，而且能看到其他事务没有提交的对已有记录的更新和删除；——有脏读问题
2. 提交读（Read Commited）：一个事务在执行过程中可以看到其他事务已经提交的新插入记录，而且能看到其他事务已经提及的对已有记录的更新和删除；——解决脏读的问题，但有不可重复读和幻读问题
3. 可重复读（Read Reaptedable）：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录（幻读），但是不能看到其他事务已经提交的对已有记录的更新和删除——解决不可重复读的问题，但未解决幻读问题；
4. 串行化（Serializable）：一个事务在执行过程中完全看不到其他事务对数据库所做的更新(事务执行的时候不允许别的事务并发执行，事务串行化执行，事务只能一个接一个的执行,而不能并发执行)；——解决脏读、不可重复度和幻读问题

### **不可重复度和幻读的区别：**

- 不可重复度：当某个事务的两次查询语句之间，有其他事务对查询结果数据进行了更新并提交（或删除并提交），则两次查询可能会得到不同的查询结果；——重点在于update和delete
- 幻读：当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会看到新插入的记录（幻行）；——重点在于insert

### **Mysql四种隔离级别实现：**

1) Read Uncommited

    读不加锁，写加排它锁，在事务结束后释放锁，会导致脏读，基本不会采取这种隔离级别

    写加排他锁，会阻止其他事务加共享锁或排他锁，但读不加任何锁，因此不受排它锁的阻碍，因此可以读到未提交的脏数据

2) RC（Read Commited）

    **快照读不加锁，基于MVCC实现，每次读都读取undo log中某个新的版本**，因此每次都读到最新的数据，但两次读可能读到不同的数据。数据的写入、修改和删除是需要加排他锁

    当前读加行锁，对于有索引的字段，会锁住相关的行，但对于没有索引的字段，会给整张表的所有数据行加行锁（升级为表锁），因为MySQL并不知道哪些数据行是符合该字段的条件的（没有索引嘛），如果一个条件无法通过索引快速过滤，存储引擎层面就会将所有记录加锁后返回，再由MySQL Server层进行过滤

3）RR（Read Reaptedable）：MySQL中InnoDB默认的隔离级别

    快照读不加锁，基于MVCC实现，每次都读undo log中某个指定的版本，解决不可重复读和幻读问题，但可能读的不是最新的数据

    当前读通过next-key锁（行锁+gap锁）解决不可重复读和幻读问题

    出于性能考虑，Mysql的Innodb引擎使用了以乐观锁为理论基础的多版本并发控制（MVCC）解决了快照读的不可重复度和幻读问题（默认隔离级别是RR，即Repeated Read）

### **Mysql InnoDB引擎的MVCC实现**

在Mysql中MVCC是在Innodb存储引擎中得到支持的，Innodb为每行记录都实现了三个隐藏字段： 6字节的事务ID（DB_TRX_ID）、7字节的回滚指针（DB_ROLL_PTR）、隐藏的ID，6字节的事物ID用来标识该行所述的事务

MVCC实现的依赖项：undo log 与 read view

1. undo log: undo log中记录的是数据表记录行的多个版本，也就是事务执行过程中的回滚段，其实就是MVCC中的一行原始数据的多个版本镜像数据；
2. read view: 主要用来判断当前版本数据的可见性；

#### **undo log（回滚日志）**

undo log是为回滚而用，具体内容就是copy事务前的数据库内容（行）到undo buffer，在适合的时间把undo buffer中的内容刷新到磁盘。undo buffer与redo buffer一样，也是环形缓冲，但当缓冲满的时候，undo buffer中的内容会也会被刷新到磁盘；与redo log不同的是，磁盘上不存在单独的undo log文件，所有的undo log均存放在主ibd数据文件中（表空间），即使客户端设置了每表一个数据文件也是如此

#### **read view**

read view用来判断当前版本数据项是否可见

在innodb中，创建一个新事务的时候，innodb会将当前系统中的活跃事务列表（trx_sys->trx_list）创建一个副本（read view），副本中保存的是当前不应该被本事务看到的其他事务id列表。当用户在这个事务中要读取该行记录的时候，innodb会将该行当前的版本号与该read view进行比较。

具体的算法如下:

1. 设该行的当前事务id为trx_id_cur，read view中最早的事务id为trx_id_min, 最迟的事务id为trx_id_max。
2. 如果trx_id_cur< trx_id_min的话，那么表明该行记录所在的事务已经在本次新事务创建之前就提交了，所以该行记录的当前值是可见的。跳到步骤6.
3. 如果trx_id_cur>trx_id_max的话，那么表明该行记录所在的事务在本次新事务创建之后才开启，所以该行记录的当前值不可见.跳到步骤5。
4. 如果trx_id_min<=trx_id_cur<=trx_id_max,那么表明该行记录所在事务在本次新事务创建的时候处于活动状态，从trx_id_min到trx_id_max进行遍历，如果trx_id_cur等于他们之中的某个事务id的话，那么不可见。跳到步骤5.
5. 从该行记录的DB_ROLL_PTR指针所指向的回滚段中取出最新的undo-log的版本号，将它赋值该trx_id_cur，然后跳到步骤2.
6. 将该可见行的值返回
需要注意的是，新建事务(当前事务)与正在内存中commit的事务不在活跃事务列表中

不同隔离级别下read view的生成原则：

1. If the transaction isolation level is REPEATABLE READ (the default level), all consistent reads within the same transaction read the snapshot established by the first such read in that transaction.
2. With READ COMMITTED isolation level, each consistent read within a transaction sets and reads its own fresh snapshot；

innodb的read view确定一条记录能否看到,有两条法则

1. 看不到read view创建时刻以后启动的事务
2. 看不到read view创建时活跃的事务

简单来说，Read View记录一致性读开始时所有的活跃事务，这些事务所做的修改对于Read View是不可见的。除此之外，所有在创建Read View之前提交的事务记录是可见的

通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。

但是注意：在RR级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据，对于这种读取历史数据的方式，我们叫它 快照读 或 一致性读(snapshot read or consistent read)

- LBCC：Lock-Based Concurrency Control，基于锁的并发控制；
- MVCC：Multi-Version Concurrency Control，基于多版本的并发控制协议。纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量；

读操作可以分成两类：

1. 快照读 (snapshot read OR consistent read)：读取的是记录的可见版本 (有可能是历史版本)，不加锁（基于MVCC，共享读锁s锁也不加，所以不会阻塞其他事务的写）；
2. 当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。

而读取数据库当前版本数据的方式，叫当前读 (current read)：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁
比如：

```
1. select * from table where ? lock in share mode;
2. select * from table where ? for update;
3. insert;
4. update;
5. delete;
```

为了解决RR隔离级别中当前读的幻读问题，MySQL事务使用了Next-Key锁，Next-Key锁是行锁和GAP（间隙锁）的合并，因为行锁可以防止不同事务版本的数据修改提交时造成数据冲突的情况，但如何避免别的事务插入数据就成了问题。因此，用行锁防止别的事务修改或删除，用GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别在写数据时的幻读问题。

GAP锁简单说，就是不仅用行锁，锁住了相应的数据行；同时也在行两边的区间都加入了gap锁，这样其他的事务就无法在行两边的区间insert进新数据

4) Serializable
从MVCC并发控制退化为基于锁的并发控制。不区分快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)，并发度急剧下降，在MySQL/InnoDB下不建议使用

### **乐观锁vs悲观锁**

1. 乐观锁：大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。
2. 悲观锁：指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）

InnoDB存储引擎的数据组织方式，是聚簇索引（或叫聚集索引）：完整的记录，存储在主键索引中，通过主键索引，就可以获取记录所有的列

简单给定一个sql语句，而不说明当前的事务隔离等级以及查询条件是否主键以及索引等条件，是无法确定加什么锁的。
比如：

```
SQL1：select * from t1 where id = 10;
SQL2：delete from t1 where id = 10;
```

SQL1是快照读，通过MVCC实现，不加锁，不在讨论范围，我们讨论SQL2这种当前读的情况。

组合一：id主键+RC
结论：id是主键时，SQL2只需要在id=10这条记录上加X锁即可（具体是加在聚簇索引的记录上）

组合二：id唯一索引+RC
结论：若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id的unique索引上的id = 10的记录，然后根据id=10找到主键值（比如name=’d’），另一把锁加在聚簇索引上的[name=’d’,id=10]的记录

组合三：id非唯一索引+RC
结论：若id列上有非唯一索引，那么对应的所有满足SQL查询条件的id索引（二级索引）的记录都会被加锁。同时，这些记录在主键索引（聚簇索引）上的记录，也会被加锁。

组合四：id无索引+RC
结论：由于id列上没有索引，因此只能走聚簇索引，进行全部扫描，聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。这是由于MySQL的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁 (违背了2PL的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。

组合五：id主键+RR
组合六：id唯一索引+RR
结论：加锁与RC情况下一致，在聚簇索引上加X锁，没有加gap锁来避免幻读，因为主键和unique约束下，都能够保证唯一性。一个等值查询，最多只能返回一条记录，而且新的相同取值的记录，一定不会在新插入进来，因此也就避免了GAP锁的使用

组合七：id非唯一索引（也即二级索引）+RR
结论：在id所在的二级索引上对满足条件的记录加行锁以及间隙锁，在主键索引（聚簇索引）上加x锁

组合八：id无索引+RR
结论：由于id列上没有索引，因此只能走聚簇索引，进行全部扫描，聚簇索引上的所有记录，都被加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。在这种情况下，这个表上，除了不加锁的快照读，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。
PS：跟组合四类似，这个情况下，MySQL也做了一些优化，就是所谓的semi-consistent read。semi-consistent read开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁

2PL：Two-Phase Locking
传统RDBMS加锁的一个原则，就是2PL (二阶段锁)：Two-Phase Locking。说的是锁操作分为两个阶段：加锁阶段与解锁阶段，并且保证加锁阶段与解锁阶段不相交，加锁阶段：只加锁，不释放锁。解锁阶段：只释放锁，不加锁。

### **锁的种类**

- 表锁：锁住整个表的数据记录；
- 行锁（Record Lock）：锁住满足条件的数据行记录；
- 间隙锁（Gap Lock）:锁住一个范围，不包括记录本身；
- Next-Key Lock：record + Gap，锁住一个范围，包括记录本身；
