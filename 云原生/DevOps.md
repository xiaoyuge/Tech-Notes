## **DevOps**

软件开发模式：瀑布 ——》敏捷 ——》DevOps

DevOps的诞生是由于互联网商业市场竞争加剧，企业为减少试错成本，往往仅推出最小可行产品，产品需要不断且高频的迭代来满足市场需求，抢占市场(产品的迭代是关乎一整条交付链的事)，高频的迭代则会促使研发团队使用敏捷模式，敏捷模式下对运维的全栈交付能力要求更严格，则运维必须开启DevOps来实现全栈交付

### **几个定义**

1. DevOps 是通过平台（Platform）、流程（Process）和人（People）的有机整合，以 C（协作）A（自动化）L（精益）M（度量）S（共享）文化为指引，旨在建立一种可以快速交付价值并且具有持续改进能力的现代化 IT 组织；

2. DevOps是各团队(已不单指开发与运维)一起紧密协作工作，以更快更好的构建、测试、发布软件交付价值为目标。DevOps发展过程中渐渐形成了DevOps文化和方法论，同时各种工具平台不断发展和出现，有了方法论和工具，接下来就是实践，大家又在实践过程中不断完善发展方法论和工具；

3. DevOps试图通过体系化的研发实践导入、软件架构的整体革新、组织管理理念的不断升级和企业文化的影响塑造，来帮助企业改善整个软件交付过程，从而真正实现又快又好的软件交付目标；

4. DevOps 涵盖开发、测试、部署、发布以及运维、监控一体化的过程管理，通过自动化工具的使用，把持续集成、持续部署、持续交付和监控、持续反馈和优化过程勾连形成一体化，又叫开发运维一体化;

### **DevOps是文化还是工具？**

1. 高效率和高质量是DevOps的核心价值，而工具和自动化就是提升效率最直接的手段，**让一切都自动化可以说是DevOps的行为准则**，但如果只是使用了最新最强大的DevOps工具，并不一定能够实现软件交付效率的腾飞，比如很多公司引入了完整的敏捷项目管理工具，但是却以传统项目管理的方式来使用这套工具，效率跟以前相比并没有明显的提升。说到底，**工具没有解决人的问题**，这个时候，就需要文化了；

2. **在不同的文化制度下，相同的人发挥出来的生产力也会有天壤之别（好的文化是生产力的放大器）**，良好的文化不仅可以让流程和工具发挥更大的作用，更重要的是，它能够诱发人们思考当前的流程和工具哪里是有问题的，从而引出更多有关流程和工具的优化需求，促使流程和工具向更加有力的支持业务发展的方向持续改进；

3. 但盲目地空谈文化，对组织也是一种伤害。因为脱离实践，文化就会变成无根之水。我们需要先改变行为，再通过行为来改变文化。而改变行为最关键的，就是要建立有效的流程或制度。比如OKR指标的设定、关键指标达成后的激励等就是一种机制，来指引员工的行动方向。通过流程和制度的改变，去影响员工行为的改变，团队的文化也在慢慢地改进；

### **DevOps倡导的文化**

- 职责共担（one team）
- 持续改进

### **VSM（Value Stream Mapping）**

也就是我们常说的价值流图。它起源于传统制造业的精益思想，用于分析和管理一个产品交付给用户所经历的业务流、信息流，以及各个阶段的移交过程。VSM就是要说清楚在需求提出后，怎么一步步地加工原材料，进行层层的质量检查，最终将产品交付给用户的过程。**通过观察完整流程中各个环节的流动效率和交付质量，识别不合理的、低效率的环节，进行优化，从而实现整体效率的提升**

因为部门职责的划分导致的软件交付过程的碎片化，所以通过**使用价值流图对软件交付过程进行建模，使整个过程可视化，从而识别出交付的瓶颈和各个环节之间的依赖关系**

DevOps三步工作法：流动、反馈、持续学习和试验

1) **流动**：关键是建立起价值流动的可视化视图（VSM），能够发现流动各环节的效率和质量问题
2) **反馈**：如果说流动是被动发现问题，反馈则是主动及时报告，通过注入流动各个过程的反馈能力，使缺陷在第一时间被发现，用户和运营数据第一时间展示，从而提升组织的响应能力
3) **持续学习和试验**：通过团队激励学习分享，将持续改进注入日常工作，使组织不断进步

### **VSM的几个关键要素和核心思想**

1. **前置时间（Lead Time）**：指一个需求从提出（典型的就是创建一个需求任务）的时间点开始，一直到最终上线交付给用户为止的时间周期。这部分时间直接体现了软件开发团队的交付速率，并且可以用来计算交付吞吐量。DevOps 的核心使命之一就是优化这段时长；
2. **增值活动时间和不增值活动时间（Value Added Time/Non-Value Added Time，简称 VAT/NVAT）**：在精益思想中，最重要的就是消除浪费，也就是说**最大化流程中那些增值活动的时长，降低不增值活动的时长**。在软件开发行业中，典型的不增值活动有很多，比如无意义的会议、需求的反复变更、开发的缺陷流向下游带来的返工等；
3. **完成度和准确度（% Complete/Accurate，简称 %C/A）**：这个指标用来表明工作的质量，也就是有多少工作因为质量不符合要求而被下游打回。这里面蕴含了大量的沟通和返工成本，从精益的视角来看，也是一种浪费；

前置时间又分为：需求前置时间 和 开发前置时间

1. **需求前置时间**：从需求提出（创建任务），到完成开发、测试、上线，最终验收通过的时间周期，考查的是团队整体的交付能力，也是用户核心感知的周期。
2. **开发前置时间**：从需求开始开发（进入开发中状态），到完成开发、测试、上线，最终验收通过的时间周期，考查的是团队的开发能力和工程能力。

研发的操作习惯会影响数据的准确性，比如有的研发喜欢一次性把所有的需求都放到开发阶段，然后再一个个处理掉，这就导致很多实际的等待时间难以识别。所以，如果完全依靠人的操作来确保流程的准确性，就会存在很大的变数。**通过流程和平台的结合，来驱动流程的自动化流转，这才是 DevOps 的正确姿势**

### **不增值时间再具体一点**

- 比如一个任务从开始到结束的周期内，有多长时间处于等待状态，比如待开发，待测试，待发布，那这些都是典型的不增值时间
- 又比如从微观角度，深入到各个环节内容，比如开发环节，统计那些除了真正写代码之外的活动时长，比如构建打包，比如提测任务，比如没人评审的提交，比如审批活动，这些理论上都是不增值的时间

**DevOps追求的是价值流动效率最大化**，所以需要看到全貌，因为就算单点能力再强，单点之间的割裂和浪费对于价值交付效率的影响也是超乎想象的

![Devops-VSM](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E4%BA%91%E5%8E%9F%E7%94%9F/resources/DevOps-VSM.jpg)

怎么才能将 DevOps 的价值和业务价值关联起来，以表明 DevOps 对业务价值的拉动和贡献？

在现在这个多变的时代，没人能够准确地预测需求的价值。所以，**交付能力的提升，可以帮助业务以最小的成本进行试错，将新功能快速交付给用户**。同时，用户和市场的情况又能够快速地反馈给业务方，从而帮助业务校准方向。同时，业务的敏捷能力也需要提升，专注于最有价值的事情

这就引入了需求优先级的问题，卡诺模型将产品需求划分为五种类型，可用来分析需求优先级：

1. **兴奋型**：指超乎用户想象的需求，是可遇不可求的功能，会给用户带来极大的满足感；
2. **期望型**：用户正好需要这个功能，而你正好提供了这个功能，用户的满意度会随着这类需求数量的增多而线性增长，做得越多，效果越好；
3. **必备型**：指产品必须要有的功能，如果没有的话，会带来非常大的影响。不过有这些功能的话，也没人会夸你做得有多好；
4. **无差别型**：指做了跟没做一样的功能，即做出来后用户几乎不用，属于无用功；
5. **反向型**：无中生有类需求，实际上根本不具备使用条件，或者用户压根不这么想。这类需求做出来以后，通常会给用户带来很大的困扰，成为被吐槽的对象；

针对这五类需求，尽量做到下面3点：

1. 优先规划期望型和必备型需求，将其纳入日常的交付迭代中，保持一定的交付节奏；
2. 识别无差别型和反向型需求；
3. 追求兴奋型需求，因为它会带来**产品的竞争壁垒和差异化**；

用户故事，是站在用户角度来思考问题，各个角色基于用户故事的讨论，目标对是想要带给用户的价值达成共识

### **看板系统（Kanban）**

看板系统是一种**拉动式的生产方式**，所谓拉动式生产，就是从后端消费者的需求出发，向前推导，需要什么就生产什么，而不是生产出来一大堆没人要的东西，从而达到减低库存、加速半成品流动和灵活响应变化的目的。

以**限制在制品数量(WIP，work in progress)、加快价值流动为核心理念**。也就是说，如果没有在制品限制的拉动系统，只能说是一个可视化系统，而不是看板系统，这一点非常重要

在制品数量就是当前团队并行处理的工作事项的数量

### **Devops的工程实践**

1. **配置管理**

   四个核心理念：
   - 版本变更标准化
   - 将一切纳入版本控制
   - 全流程可追溯
   - 单一可信数据源

- 版本变更标准化

   版本控制是配置管理中的一个非常核心的概念

   配置管理中的另一个核心概念是变更，版本来源于变更。对于变更而言，核心就是要记录：谁，在什么时间，做了什么改动，具体改了哪些内容，又是谁批准的

   改动说明一般就是版本控制系统的提交记录，一个完整的提交记录应该至少包括以下几个方面的内容：
   1. 提交概要信息：简明扼要地用一句话说明这个改动实现了哪些功能，修复了哪些问题；
   2. 提交详细信息：详细说明改动的细节和改动方式，是否有潜在的风险和遗留问题等；
   3. 提交关联需求：是哪次变更导致的这次提交修改，还需要添加上游系统编号以关联提交和原始变更；

   如果标准化流程要完全依靠人的自觉性来保障，那就太不靠谱了。毕竟，人总是容易犯错的，会影响到标准的执行效果。所以，当团队内部经过不断磨合，逐步形成一套规范之后，最好还是用自动化的手段保障流程的标准化

   标准化/规范化是自动化的前提，**自动化又是 DevOps 最核心的实践**

- **将一切纳入版本控制**

   这是配置管理的金科玉律。你可能会问，需要将什么样的内容纳入版本控制呢？我会毫不犹豫地回答你：“一切都需要！”比如软件源代码、配置文件、测试编译脚本、流水线配置、环境配置、数据库变更等等，你能想到的一切，皆有版本，皆要被纳入管控

   软件本身就是一个复杂的集合体，任何变更都可能带来问题，所以，全程版本控制赋予了我们全流程追溯的能力，并且可以快速回退到某个时间点的版本状态，这对于定位和修复问题是非常重要的

   如果对所有内容都纳入版本控制，快速对比两个版本，列出差异点，对于快速定位和解决问题有极大帮助

   **很多 DevOps 实践都是基于版本控制来实现的**，比如，环境管理方面推荐采用**基础设施即代码的方式管理环境，也就是说把用代码化的方式描述复杂的环境配置，同时把它纳入版本控制系统中**。这样一来，任何环境变更都可以像提交代码一样来完成，不仅变更的内容一目了然，还可以很轻松地实现自动化。这样一来，开发和运维之间的鸿沟就被逐渐抹平了，DevOps 的真谛也是如此

   需要澄清的是，纳入版本控制并不等同于把所有内容都放到 Git 中管理。有些时候，我们很容易把能力和工具混为一谈。Git 只是一种流行的版本控制系统而已，而这里强调的其实是一种能力，工具只是能力的载体。比如，Git 本身不擅长管理大文件，那么可以把这些大文件放到 Artifactory 或者其他自建平台上进行管理

   在实践将一切纳入版本控制的时候，你可以参考一条小原则。如果你不确定是否需要纳入版本控制，有一个简单的判断方法就是：如果这个产物可以通过其他产物来重现，那么就可以作为制品管理，而无需纳入版本控制

   比如：软件包可以通过源代码和工具重新打包生成，那么，代码、工具和打包环境就需要纳入管控，而生成的软件包可以作为制品；软件的测试报告如果可以通过测试管理平台重新自动化生成，那么同样可以将其视为制品，但前提是，测试管理平台可以针对每一个版本重新生成测试报告

2. **分支策略**

   - 2.1 **主干开发，分支发布**

    ![mainDev-branchDeliver](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E4%BA%91%E5%8E%9F%E7%94%9F/resources/mainDev-branchDiliver.png)

     在这种分支策略下，开发团队共享一条主干分支，所有的代码都直接提交到主干分支上，主干分支就相当于是一个代码的全量合集。在软件版本发布之前，会基于主干拉出一条**以发布为目的的短分支**

      1. **以发布为目的**：这条分支存在的意义不是开发新功能，而是对现有功能进行验收，并在达到一定的质量标准后对外发布。一般来说，新功能不会基于这条分支提交，只有一些 Bugfix 会集成进来。所以，对于这种发布分支会有比较严格的权限管控。毕竟，谁都不想让那些乱七八糟、未经验证的功能跑到发布分支上来；

      2. **短分支**：这条发布分支一般不会存在太长时间，只要经过回归验证，满足发布标准后，就可以直接对外发布，这时，这条分支的历史使命也就结束了。除非上线之后发现一些紧急问题需要修复，才会继续在这条分支上修改验证，并将改动同步回主干分支。所以，只要在主干分支和发布分支并行存在的时间段内，所有发布分支上的改动都需要同步回主分支，这也是我们不希望这条分支存在时间过长的原因，因为这会导致重复工作量的线性累计；

这种模式的优势有三个：

1. 对于研发团队来说，只有一条主线分支，不需要在多条分支间切换；
2. 在发布分支拉出之后，主干分支依然处于可集成状态，研发节奏可以保持在一个相对平稳的状态；
3. 发布分支一般以版本号命名，清晰易懂，线上哪个版本出了问题，就在哪个分支上修复；

这种模式也存在着缺点和挑战：

1. 对主线分支的质量要求很高：如果主线分支出了问题，就会 block 所有开发团队的工作。对于一个百人团队、每日千次的提交规模来说，如果不对提交加以约束，这种情况的发生频率就会非常高；
2. 它对团队协作的节奏要求很高：如果主线分支上的功能没有及时合入，但是业务方又坚持要在指定版本上线这个功能，这就会导致发布分支“难产”。甚至有些时候，会被迫允许部分未开发完成的功能在发布分支上继续开发，这会给发布分支的质量和稳定性造成很大的挑战；
3. 在主线和发布分支并存期间，有可能会导致两边提交不同步的情况：比如，发布分支修复了一个线上问题，但是由于没有同步回主线，导致同样的问题在下一个版本中复现。测试出来的问题越多，这种情况出现的概率就越大，更不要说多版本并存的情况了；

这些问题的解决方法包括以下几点：

1. 建立提交的准入门禁，不允许不符合质量标准的代码合入主线；
2. 采用版本火车的方式，加快版本的迭代速度，功能“持票上车”，如果跟不上这个版本就随下个版本上线。另外，可以采用功能开关、热修复等手段，打破版本发布的固定节奏，以一种更加灵活的方式对外发布；
3. 通过自动化手段扫描主线和发布分支的差异，建立一种规则。比如 Hotfix 必须主线和发布分支同时提交，或者发布分支上线后，由专人反向同步等；

（2）分支开发，主干发布

![branchDev-mainDeliver](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E4%BA%91%E5%8E%9F%E7%94%9F/resources/branchDev-mainDeliver.png)

当开发接到一个任务后，会基于主干拉出一条特性开发分支，在特性分支上完成功能开发验证之后，通过 Merge request 或者 Pull request 的方式发起合并请求，在评审通过后合入主干，并在主干完成功能的回归测试。开源社区流行的 GitHub 模式其实就是属于这种

还可以进一步细分为两种情况：

1. 每条特性分支以特性编号或需求编号命名，在这条分支上，只完成一个功能的开发；
2. 以开发模块为单位，拉出一条长线的特性分支，并在这条分支上进行开发协作；

两者的区别就在于特性分支存活的周期，拉出时间越长，跟主干分支的差异就越大，分支合并回去的冲突也就越大。所以，对于长线模式来说，要么是模块拆分得比较清晰，不会有其他人动这块功能，要么就是保持同主干的频繁同步。随着需求拆分粒度的变小，短分支的方式其实更合适

这种模式下的优势：

1. 分支开发相对比较独立，不会因为并行导致互相干扰。同时，特性只有在开发完成并验收通过后才会合入主干，对主干分支的质量起到了保护作用；
2. 随着特性分支的流行，在这种模式下，分支成了特性天然的载体。一个特性所关联的所有代码可以保存在一条特性分支上，这为以特性为粒度进行发布的模式来说提供了一种新的可能性。也就是说，如果你想要发布哪个特性，就可以直接将特性分支合并到发布分支上，这就让某一个特性变得“可上可下”，而不是混在一大堆代码当中，想拆也拆不出来；

缺点和挑战：

1. 非常考验团队特性拆分的能力。如果一个特性过大，会导致大量并行开发的分支存在，分支的集成周期拉长，潜在的冲突也会增多。另外，分支长期存在也会造成跟主线差异过大的问题。所以，特性的粒度和分支存活的周期是关键要素。根据经验来看，分支存活的周期一般不要超过一周；
2. 对特性分支的命名规范要求很高。由于大量特性分支的拉出，整个代码仓库会显得非常乱。面对一大堆分支，谁也说不清到底哪个还活着，哪个已经没用了。所以，如果能够跟变更管理系统打通，自动化创建分支就最好了；
3. 特性分支的原子性和完整性，保证一个特性的关联改动需要提交到一条分支上，而不是到处都是。同时，特性分支上的提交也需要尽量清晰，典型的就是原子性提交；

在合入主干的时候，为了保证代码的原子性，其实是有机会对代码提交进行重新编排的，Git 在这方面可以说非常强大。如果你熟练掌握 git rebase 命令，就可以快速合并分拆提交，将每一个提交整理为有意义的原子性的提交，再合入主干，或者干脆把特性分支上的改动压合成一个提交。当然，这样做的代价就是不断重写特性分支的历史，给研发团队带来额外的工作量

（3）主干开发，主干发布

![mainDev-mainDeliver](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E4%BA%91%E5%8E%9F%E7%94%9F/resources/mainDev-mainDeliver.png)

这种分支策略可以简单理解为没有策略。团队只有一条分支，开发人员的代码改动都直接集成到这条主干分支上，同时，软件的发布也基于这条主干分支进行。

对于持续交付而言，最理想的情况就是，每一次提交都能经历一系列的自动化环境并部署到生产环境上面，而这种模式距离这个目标就更近了一点

如果想要做到主干分支在任何时间都处于可发布状态，那么，这就对每一次提交的代码质量要求非常高

Facebook的主干开发、主干发布策略
为了保证主干分支的质量，自动化验收手段是必不可少的，因此，每一次代码提交都会触发完整的编译构建、单元测试（应该还有code reivew）、代码扫描、自动化测试等过程。在代码合入主干后，会进行按需发布，先是发布到内部环境（预发环境），也就是只有 Facebook 的员工才能看到这个版本，如果发现问题就立刻修复，如果没有问题，再进一步开放发布给 2% 的线上生产用户（灰度），同时自动化检测线上的反馈数据。直到确认一切正常，才会对所有用户开放

![Facebook-mainDev-mainDeliver](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E4%BA%91%E5%8E%9F%E7%94%9F/resources/Facebook-mainDev-mainDeliver.jpg)

推荐的分支策略：
主干开发结合特性分支的模式，也就是团队共享一条开发主干，特性开发基于主干拉出特性分支，快速开发验收并回归主干，同时，在特性分支和主干分别建立不同的质量门禁和自动化验收能力

![recommend-branch-strategy](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E4%BA%91%E5%8E%9F%E7%94%9F/resources/recommend-branch-strategy.jpg)

### **持续集成**

瀑布开发模式时代的问题：在很长一段时间里，软件是根本无法运行的

CI 是一种软件开发实践，团队成员频繁地将他们的工作成果集成到一起（通常每人每天至少提交一次，这样每天就会有多次集成），并且在每次提交后，自动触发运行一次包含自动化验证集的构建任务，以便尽早地发现集成问题

CI核心要做到三点：

1. 快速集成：每次提交触发完整的流水线，如果想做到每次提交都触发持续集成的话
    - 1.1  需要打通版本控制系统和持续集成系统，比如 GitLab 和 Jenkins 的集成；
    - 1.2 统一的分支策略：**需要有一条以集成为目的的分支**，这条分支可以是研发主线，也可以是专门的集成分支，一旦这条分支上发生任何变更，就会触发相应的 CI 过程；
    - 1.3 清晰的集成规则：对于研发特性分支而言，目的主要是快速验证和反馈，那么速度就是不可忽视的因素，所以这个层面的持续集成，主要以验证打包和代码质量为主；而对于系统集成分支而言，它的目的不仅是验证打包和代码质量，还要关注接口和业务层面的正确性，所以集成的步骤会更加复杂，成本也会随之上升；
    - 1.4 标准化的资源池：资源池需要实现环境标准化，也就是任何任务在任何节点都具备可运行的能力，资源池的并发吞吐量应该可以满足集中提交的场景，可以动态按需初始化的资源池就成了最佳选择；
    - 1.5 足够快的反馈周期：越是初级 CI，对速度的敏感性就越强。一般来讲，如果 CI 环节超过 10～15 分钟还没有反馈结果，那么研发人员就会失去耐心，所以 CI 的运行速度是一个需要纳入监控的重要指标。对于不同的系统而言，要约定能够容忍的 CI 最大时长，如果超过这个时长，同样会导致 CI 失败。所以，这就需要环境、平台、开发团队共同维护

2. 每次流水线触发自动化测试：CI 的目的是尽早发现问题，这些问题既包括构建失败，也包括质量不达标，比如测试不通过，或者代码规约静态扫描等不符合标准
    - 2.1 **匹配合适的测试活动**：对于不同层级的 CI 而言，同样需要根据集成规则来确定需要注入的质量活动。比如，最初级的提交集成就不适合那些运行过于复杂、时间太长的测试活动，快速的静态代码检查和冒烟测试就足以证明这个版本已经达到了最基本的要求。而对于系统层的集成来说，质量要求会更高，这样一来，一些接口测试、UI测试等就可以纳入到 CI 里面来；
    - 2.2 **树立测试结果的公信度**：自动化测试的目标是帮助研发提前发现问题，但是，如果因为自动化测试能力自身的缺陷或者环境不稳定等因素，造成了 CI 的大量失败，那么，这个 CI 对于研发来说就可有可无了。所以，我们要对 CI 失败进行分类分级，重点关注那些异常和误报的情况，并进行相应的持续优化和改善；
    - 2.3 考虑到 CI 对于速度的敏感性，那么如何在最短的时间内运行最有效的测试任务，就成了一个关键问题。显然，大而全的测试套件是不合时宜的，只有在基础功能验证的基础上，结合与本次 CI 的变更点相关的测试任务，发现问题的概率才会大大提升。所以，根据 CI 变更，自动识别匹配对应的测试任务也是一个挑战；

3. 出了问题可以在第一时间修复：真正让 CI 发挥价值的关键，还是在于团队面对持续集成的态度，以及团队内是否建立了持续集成的文化。
    - 3.1 建立机制：对于 CI 而言，保证集成主线的可用性，其实就是团队成员间的一种约定。这不在于谁出的问题谁去修复，而在于我们是否能够保证 CI 的稳定性，足够清楚问题的降级路径，并且主动关注、分析和推动问题解决；
    - 3.2 建立规则：比如 10 分钟内没有修复则自动回滚代码，比如当 CI“亮红灯”的时候，团队不再提交新的代码，因为在错误的基础上没有办法验证新的提交，这时需要集体放下手中的工作，共同恢复 CI 的状态；

### **自动化测试**

要解决的问题：日益快速的迭代周期下要测试的内容越来越多与测试的时间越来越短的矛盾问题

自动化测试适用于以下几种典型场景：

1. 有大量机械的重复操作，并且会反复执行的场景，比如批量的回归测试；
2. 有明确的设计规范且相对稳定的场景，比如接口测试；
3. 大批量、跨平台的兼容性测试，比如覆盖多种版本和多种机型的测试，几十个机型还可以接受，如果覆盖成百上千个机型，就只能依靠自动化了；
4. 长时间不间断执行的测试，比如压力测试、可用性测试等；

### **单元测试 vs API测试  vs UI测试**

从左至右，用例的执行速度越来越慢，维护成本也越来越高

- **单元测试**：单元测试更多是由开发主导的，开发领导的态度就决定了运行的效果。但不可否认的是，单元测试还是非常必要的，尤其是针对核心服务，比如核心交易模块的覆盖率。当然，好的单元测试需要研发投入大量的精力；
- **API测试**：综合考虑投入产出比和上手难度的话，位于中间层的接口测试就成了一种很好的选择。一方面，现代软件架构无论是分层还是服务调用模式，对接口的依赖程度都大大增加。比如典型的前后端分离的开发模式，前后端基本都是在围绕着接口进行开发联调。另一方面，**与单元测试相比，接口测试调用的业务逻辑更加完整**，并且具备清晰的接口定义，适合采用自动化的方式执行；
- **UI测试**：UI 层是唯一能够模拟用户真实操作场景的端到端测试，页面上的一个按钮可能触发内部几十个函数调用，和单元测试每次只检查一个函数的逻辑不同，**UI 测试更加关注模块集成后的联动逻辑，是集成测试最有效的手段**。但缺点也是比较明显的：随着敏捷迭代的速度越来越快，UI 控件的频繁变更会导致控件定位不稳定，提高了用例脚本的维护成本；

![automaiton-test-level](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E4%BA%91%E5%8E%9F%E7%94%9F/resources/automaiton-test-level.png)

### **内建质量**

质量管理大师爱德华·戴明博士经典的质量管理 14 条原则第 3 条指出：不应该将质量依赖于检验工作，因为检验工作既昂贵，又不可靠。最重要的是，检验工作并不直接提升产品质量，只是为了证明质量有缺陷。而正确的做法是将质量内建于整个流程之中，并通过有效的控制手段来证明流程自身的有效性

将质量内建于开发交付流程的各个环节，在源头把控质量，出现问题流程立刻停止，以及不要依靠检验工作来保障质量

安灯系统：丰田的汽车生产线上方有一条绳子，如果生产线上的员工发现了质量问题，就可以拉动安灯系统通知管理人员，并停止生产线，以避免带有缺陷的产品不断流向下游。

这背后的理念就是“Fail fast”，即快速失败。如果工人发现了有缺陷的产品，却要经过层层审批才能停止生产线，就会有大量带有缺陷的产品流向下游，所以，停止生产线并不是目的，及时发现问题和解决问题才是目的

内建质量有两个核心原则：

1. 问题发现得越早，修复成本就越低；
2. 质量是每个人的责任，而不是质量团队的责任；

内建质量，需要我们在软件交付的各个环节中注入质量控制的能力

1. 在需求环节，可以定义清晰的**需求准入规则**，比如需求的价值衡量指标是否客观、需求的技术可行性是否经过了验证、需求的依赖是否充分评估、需求描述是否清晰、需求拆分是否合理、需求验收条件是否明确等等，通过前置需求质量控制，可以减少不靠谱的需求流入；
2. 在开发阶段，代码评审和持续集成就是一个非常好的内建质量的实践。在代码评审中，要尽量确认编码是否和需求相匹配，业务逻辑是否清晰。另外，通过一系列的自动化检查机制，来验证编码风格、风险、安全漏洞等；
3. 在测试阶段，可以通过各类自动化测试，以及手工探索测试，覆盖安全、性能、可靠性等，来保障产品质量；
4. 在部署和发布阶段，可以增加灰度上线、数据库监控、危险操作扫描、线上业务监控等多种手段；

根据内建质量的第一原则，我们知道，如果可以在代码刚刚提交的时候就发现和修复缺陷，成本和影响都是最低的。如果等到产品上线后，发现了线上质量问题，再回过头来定位和修复问题，并重新发布软件，成本将会呈指数级增长

所以，研发环节作为整个软件产品的源头，是内建质量的最佳选择

### **技术债务**

技术债务，就是指团队在开发过程中，为了实现短期目标选择了一种权宜之计，而非更好的解决方案，所要付出的代价。这个代价就是团队后续维护这套代码的额外工作成本，并且只要是债务就会有利息，债务偿还得越晚，代价也就越高

DevOps 的关注点要从研发环节继续向上游延伸，一直把业务团队包括进来。也就是说，IT 部门不仅仅是被动的按照业务需求交付功能，还要更加快速地提供业务数据反馈，辅助业务决策。同时，交付能力的提升也进一步降低了业务的试错成本，而业务的敏捷性也决定了研发交付的需求价值和交付节奏，通过影响地图进行需求分析，再通过卡诺模型分析需求属性和优先级，通过用户故事和整个团队达成共识，通过持续快速验证，帮助产品在正确的道路上发展前进

引入业务的 DevOps，就成了 BizDevOps，这也是 DevOps 发展的一种潮流
