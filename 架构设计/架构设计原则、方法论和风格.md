## **架构设计的原则和方法论**

1. **面向对象设计的SOLID原则**：

    S.O.L.I.D是面向对象设计和编程(OOD&OOP)中几个重要编码原则(Programming Priciple)的首字母缩写

    - **SRP The Single Responsibility Principle ：单一责任原则**

      当需要**修改某个类的时候原因有且只有一个**（THERE SHOULD NEVER BE MORE THAN ONE REASON FOR A CLASS TO CHANGE）。换句话说就是**让一个类只承担一种责任**，当这个类需要承当其他责任的时候，就需要分解这个类

      从面向对象角度解释这个原则为："**引起类变化的因素永远不要多于一个。**" 或者说 "一个类有且仅有一个职责"。这似乎不太好理解，特别是"引起类变化的因素永远不要多于一个。"这句话更是有点虚，让人有点摸不着头脑。我们通常都说“低耦合，高内聚”。在我看来，这里的"单一职责"就是我们通常所说的“高内聚”，即一个类只完成它应该完成的职责，不能推诿责任，也不可越殂代疱，不能成为无所不能的上帝类。如果你的团队中实施宽松的“代码集体所有权”，在编码的过程中出现许多人同时修改（维护）同一个类的现象，而且成员之间的沟通不够及时，主动和畅通的话，那么时间一长，就很可能出现“承担过多职责”的上帝类。这时，提炼基类/接口和提炼类重构将能帮助我们消除或减轻这种设计臭味。

    - **OCP The Open Closed Principle ：开闭原则**

      软件实体应该是可扩展，而不可修改的。也就是说，**对扩展是开放的，而对修改是封闭的**

      从面向对象设计角度看，这个原则可以这么理解："软件实体(类,模块,函数等等)应当对扩展开放，对修改闭合。" 通俗来讲，它意味着你（或者类的客户）**应当能在不修改一个类的前提下扩展这个类的行为**。在OOD里，对扩展开放意味着类或模块的行为能够改变，在需求变化时我们能以新的，不同的方式让模块改变，或者在新的应用中满足需求。也就是说，对扩展是开放的，而对修改是封闭的。我们通常都说：**向系统中增加功能时应该只是添加新代码，而应该尽量少的修改原代码**。在我看来，这就是遵循开放封闭原则所能带来的效果。曾经在网上看到过这样一句话“哪里变化，封装哪里”。这其实就是说，我们要将系统中可能变化的地方封装起来，即对修改封闭。同时，为了应对系统需求（功能）的扩展，需要抽象！

    - **LSP The Liskov Substitution Principle ：里氏替换原则**

      当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系

      Liskov's 替换原则意思是："**子类型必须能够替换它们的基类型**。"或者换个说法："使用基类引用的地方必须能使用继承类的对象而不必知道它。" 这个原则正是保证继承能够被正确使用的前提。通常我们都说，“优先使用组合（委托）而不是继承”或者说“只有在确定是 is-a 的关系时才能使用继承”，因为继承经常导致”紧耦合“的设计

    - **ISP The Interface Segregation Principle :接口分离原则**

      不能强迫用户去依赖那些他们不使用的接口。换句话说，**使用多个专门的接口比使用单一的总接口总要好**

      这个原则的意思是"**客户端不应该被迫依赖于它们不用的接口。**" 也就是说，一个接口或者类应该拥有尽可能少的行为（那么，什么叫尽可能少？就是少到恰好能完成它自身的职责），这也是保证“软件系统模块的粒度尽可能少，以达到高度可重用的目的。接口包含太多的方法会降低其可用性，像这种包含了无用方法的"胖接口"会增加类之间的耦合。如果一个类想实现该接口,那么它需要实现所有的方法,尽管有些对它来说可能完全没用，所以这样做会在系统中引入不必要的复杂度，降低代码的可维护性或鲁棒性。接口分离原则确保实现的接口有它们共同的职责,它们是明确的,易理解的,可复用的.

    - **DIP The Dependency Inversion Principle ： 依赖倒置原则**
      1. 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 
      2. 抽象不应该依赖于细节，细节应该依赖于抽象

      这个原则的意思是：高层模块不应该依赖底层模块，两者都应该依赖其抽象。其实又是”**面向接口编程，不要面向实现编程**“的内在要求。

2. **KISS原则**

    KISS原则是英语 Keep It Simple Stupid 的首字母缩略字，是一种归纳过的经验原则。KISS 原则是**指在设计当中应当注重简约的原则**。总结工程专业人员在设计过程中的经验，大多数系统的设计应保持简洁和单纯，而**不掺入非必要的复杂性**，这样的系统运作成效会取得最优；因此简单性应该是设计中的关键目标，**尽量回避免不必要的复杂性**

    保持简单（避免复杂）永远是你应该做的第一件事，简单的代码不仅写起来简单、不容易出Bug，还易于维护。简单规则下，还包括：
    * Don’t Make Me Think：如果一段程序对于阅读者来说需要花费太多的努力才能理解，那它很可能需要进一步简化；
    * 最少意外原则：程序代码应尽可能的不要让阅读者感到意外。也就是说应该遵循编码规范和常见习惯，按照公认的习惯方式进行组织和命名，不符常规的编程动作应该尽可能的避免；

3. **DRY原则**

    DRY即Don’t repeat yourself（不要重复你自己，简称DRY），或一个规则，实现一次（One rule, one place）是面向对象编程中的基本原则，程序员的行事准则。旨在软件开发中，减少重复的信息。**DRY的原则是“系统中的每一部分，都必须有一个单一的、明确的、权威的代表”，**指的是（由人编写而非机器生成的）代码和测试所构成的系统，必须能够表达所应表达的内容，但是不能含有任何重复代码。当DRY原则被成功应用时，一个系统中任何单个元素的修改都不需要与其逻辑无关的其他元素发生改变。此外，与之逻辑上相关的其他元素的变化均为可预见的、均匀的，并如此保持同步

    对DRY的理解：
    * 尽可能的减少重复，如代码重复、文档重复、数据重复、表征重复、开发人员重复（相同的功能不能的开发人员的优自己的实现）；
    * 不重复造轮子，能够使用开源的解决方案的情况下没有必要再实现一遍；
    * 重复的事项，尽可能的使用自动化程序解决；
    * 不要过于优化，过度追求DRY，破坏了程序的内聚性；

4. **Code for the maintainer**

    为维护者编写程序。比如让代码有自解释的功能。在你编写代码的时候永远记得将来需要维护他。

5. **系统设计的正交性**

    正交性”是几何学中的术语，互为直角的直角坐标系就具有正交性；在计算技术中表示**不依赖性或解耦性**
      
    非正交的系统意味着系统中各组件互相高度依赖

6. **Design for failure**

    设计架构的时候，**需要假设问题或故障一定会出现**，设计的架构要提前思考容灾和灾备的方案，以应对当故障真实发生时的快速容错（比如fail fast）、故障转移（比如fail over）

7. **凤凰架构原则**

    为了得到高质量的软件产品，我们是应该把精力更多地集中在提升每一个人员、过程、产出物的能力和质量上？还是应该把更多精力放在整理流程和架构上？如何用一些“不可靠”的部件构造出一个可靠的系统？

    如果一项工作要经过多个“不靠谱”的过程相互协作完成，其中的误差应该会不断累计叠加，导致最终结果必然不能收敛稳定。解决问题的关键点在于**承认零部件可能会出错，某个具体的零部件可能会崩溃消亡，但在存续生命的微生态系统中其后代一定会出现，重新代替该零部件，实现他的作用，以维持系统的整体稳定**。在这个微生态里，每一个部件都可以看作一只“不死鸟”（Phoenix），它会老迈，又能涅槃重生。

    从大型机-》原始分布式-》大型单体-》SOA-》微服务-》服务网格-》无服务这系列服务架构演变的最重要驱动力，始终都是为了方便某个服务能够顺利地死去和重生。个体服务的生死更迭，是关系到整个系统能否可靠存续的关键。

    有老朽、有消亡、有重生、有更迭，才是生态运行的合理规律。设想一下，如果系统中每个部件都符合“Phoenix”特性，哪怕其中某些部件采用了由极不靠谱的人员所开发的极不靠谱的程序，哪怕存在严重的内存泄露问题，哪怕最多只能服务三分钟就会崩溃，只要在整体架构设计中有恰当且自动化的错误熔断、服务淘汰和重建机制，从系统外部观察来看，架构仍然有可能表现出稳定和健壮的服务能力

    核心：无法依赖单个组件或服务完全可靠，需要依赖系统整体可靠，靠的就是系统的每个组成部分，都能够在出错的时候，实现错误兼容并重生

8. 架构不是被发明和设计出来的，而是**持续演进**的结果

9. 云计算数据中心的处理能力几乎可以认为是无限的，能够通过扩展硬件的手段解决问题就尽量别使用复杂的软件方法，因为硬件的成本能够持续稳定地下降，而软件开发的成本则不可能——这也是KISS原则的一种体现

10. 任何架构设计都不是完美的，都是针对某个特定场景特定目标下的解决方案，在进行架构决策的时候，需要想清楚当前场景下优先解决的目标是是什么，比如是否可以牺牲部分性能优先保证可伸缩性

    比如分层架构下，如果我们把每个层次独立部署，层次间通过网络来交互，那么多层的架构在性能上会有损耗。这也是为什么服务化架构性能要比单体架构略差的原因，也就是所谓的“多一跳”问题。但会带来分层独立部署后的方便伸缩的好处，所以需要**权衡针对所处的业务场景哪个是最优先考虑的目标**

11. **三高架构**
  - 高可用：主要指服务要实现为无状态服务，这样就能无限横向扩展进行冗余，实现对高可用的支撑
  - 高性能：主要由吞吐量和响应时间（RT：Response Time）决定
  - 高可靠：主要指数据


