## **高并发系统设计的通用方法论**：
1. **Scale up 和 Scale-out**
    - **Scale-up**：通过购买性能更好的硬件来提升系统的并发处理能力，也即尽量提升单服务器的性能，将单服务器的性能发挥到极致，比方说目前系统 4 核 4G 每秒可以处理 200 次请求，那么如果要处理 400 次请求呢？很简单，我们把机器的硬件提升到 8 核 8G（硬件资源的提升可能不是线性的，这里仅为参考）;
    - **Scale-out**：则是另外一个思路，它通过将多个低性能的机器组成一个分布式集群来共同抵御高并发流量的冲击。沿用刚才的例子，我们可以使用两台 4 核 4G 的机器来处理那 400 次请求；

    ### **什么时候选择 Scale-up，什么时候选择 Scale-out ？**
    一般来讲，在我们系统设计初期会优先考虑使用 Scale-up 的方式，因为这种方案足够简单，所谓能用堆砌硬件解决的问题就用硬件来解决，但是当系统并发超过了单机的极限时，我们就要使用 Scale-out 的方式。

    Scale-out 虽然能够突破单机的限制，但也会引入一些复杂问题。比如，如果某个节点出现故障如何保证整体可用性？当多个节点有状态需要同步时如何保证状态信息在不同节点的一致性？如何做到使用方无感知的增加和删除节点？

    单服务器提升性能除了硬件升级，还可以提升单服务处理并发请求的能力，这里主要涉及IO模型和并发模型。

    I/O 模型：阻塞、非阻塞、同步、异步

    并发模型：多进程（PPC、prefork）、多线程（tpc、prethread）、协程（coroutine）

    针对IO密集型应用，需要考虑更高效的IO模型，比如非阻塞IO、IO多路复用

    针对CPU密集型应用，需要考虑更高效的并发模型，尽量能用更少量的资源占用并尽量利用CPU多核能力（比如协程）

2. **分而治之（Scale-out、Sharding等）**
    - **应用层的分而治之**：Scale-out（横向扩展），是一种常见的高并发系统设计方法，采用分布式部署的方式把流量分流开，让每个服务器都承担一部分并发和流量，需要服务是stateless的
    - **数据层的分而治之**：Sharding（数据分片），如map-reduce、分库分表等

3. **缓存**

    对CPU开销大的操作进行提前计算并缓存。对于IO开销大的操作，用更高效的存储替换低效存储，比如数据从磁盘放入内存，而内存缓存可以按照离应用/用户的远近（减少IO成本）可以分为
    - 分布式缓存
    - 应用本地缓存
    - 流量入口缓存（如网关、负载均衡服务等）
    - 浏览器/APP缓存等

4. **异步**

    以方法调用为例，同步调用代表调用方要阻塞等待被调用方法中的逻辑执行完成。这种方式下，当被调用方法响应时间较长时，会造成调用方长久的阻塞，在高并发下会造成整体系统性能下降甚至发生雪崩。异步调用恰恰相反，调用方不需要等待方法逻辑执行完成就可以返回执行其他的逻辑，在被调用方法执行完毕后再通过回调、事件通知等方式将结果反馈给调用方

5. **分层架构**

    比如MVC、表现层|逻辑层|数据访问层等，不同的分层专注做这一层该做的事情，可以提升复用性，比如某一层具有一定的通用性，那么我们可以把它抽取独立出来。同时可以方便按分层进行横向扩展，比如如果业务逻辑里面包含有比较复杂的计算，导致 CPU 成为性能的瓶颈，那这样就可以把逻辑层单独抽取出来独立部署，然后只对逻辑层来做扩展


## **性能优化策略总结**

核心原则：
* 目标导向：在做性能优化的时候要明确目标，在目标明确的情况下，持续不断地寻找性能瓶颈，制定优化方案，直到达到目标为止；
* 数据驱动：通过数据帮助发现性能瓶颈，对性能问题和优化目标进行量化，并对性能提升程度进行度量；
* 二八原则：用 20% 的精力解决 80% 的性能问题。抓住主要矛盾，优先优化主要的性能瓶颈点；

程序代码总的来说，有两种运行模式，即 CPU 密集型与 IO 密集型

* CPU 密集型操作，顾名思义就是需要持续依赖 CPU 资源来执行的操作，比如各种逻辑计算、解析、判断等等。在这种情况下，我们的优化方向是
    * 从代码层面考虑优化，比如选用更高效的算法或者减少运算次数
    * 尽可能地利用多核 CPU 资源，并且避免让 CPU 做无效的切换
    * 对于可以预先计算且时效性要求不高的场景，可以考虑将计算结果预先计算好并缓存
    * 发现这类问题的主要方式，是通过一些 Profile 工具来找到消耗 CPU 时间最多的方法或者模块，比如 Linux 的 perf、eBPF 等

* IO 密集型操作，比如磁盘 IO 或者网络 IO，这个过程操作系统会挂起任务线程，让出 CPU 资源，我们熟知的系统大部分都属于 IO 密集型，比如数据库系统、缓存系统、Web 系统。这类系统的性能瓶颈可能出在系统内部，也可能是依赖的其他系统。所以此时我们需要
    * 适当地增加任务线程数量，来提高吞吐量，由于业务中的阻塞请求比较多，所以可以将配置的线程数提高到可用 CPU 核数的两倍以上，但也不能无限增加线程的数量，毕竟资源有限
    * 使用更高效的IO，比如同步非阻塞IO、异步非阻塞IO等，使用少量的线程来处理大量的请求（IO多路复用）；
    * 优化方案会随着问题的不同而不同。比方说，如果是数据库访问慢，那么就要看是不是有锁表的情况、是不是有全表扫描、索引加的是否合适、是否有 JOIN 操作、需不需要加缓存，等等；如果是网络的问题，就要看网络的参数是否有优化的空间，抓包来看是否有大量的超时重传，网卡是否有大量丢包等

我们开发的绝大多数业务系统，都是 IO 密集型系统，IO 密集型系统大部分时间都在执行 IO 操作，这个 IO 操作主要包括网络 IO 和磁盘 IO，以及与计算机连接的一些外围设备的访问。与之相对的CPU密集型系统，大部分时间都是在使用 CPU 执行计算操作。我们开发的业务系统，很少有非常耗时的计算，更多的是网络收发数据，读写磁盘和数据库这些 IO 操作。这样的系统基本上都是 IO 密集型系统

另外，在进行系统性能优化的时候，我们可以系统性地从如下这些方面，来分别考虑优化的思路：
1. 代码：有一些性能问题，完全是由于代码写的不合理，通过直接修改一下代码就能解决问题的，比如for循环次数过多、作了很多无谓的条件判断、相同逻辑重复多次等。可以通过分布式链路跟踪工具拿到各个环节的性能数据，有针对性地优化。或者是在多线程并发情况下没有合理使用锁导致的并发性能差；
2. 数据库：
    - 2.1 SQL 调优：最常见的方式是，由自带的慢查询日志或者开源的慢查询系统定位到具体的出问题的SQL，然后使用explain、profile等工具来逐步调优，最后经过测试达到效果后上线；
    - 2.2 架构调优：读写分离、多从库负载均衡、垂直和水平分库分表；
    - 2.3 数据库连接池：应用为了实现数据库连接的高效获取、对数据库连接的限流等目的，通常会采用连接池类的方案，即每一个应用节点都管理了一个到各个数据库的连接池，随着业务访问量或者数据量的增长，原有的连接池参数可能不能很好地满足需求，这个时候就需要结合当前使用连接池的原理、具体的连接池监控数据和当前的业务量作一个综合的判断，通过反复的几次调试得到最终的调优参数；

3. 缓存：如果数据读多写少且更新不频繁，数据库扛不住更高的并发时候，可以考虑在数据库前面加一层缓存来扛更高的并发；

4. 异步： 针对某些客户端的请求，在服务端可能需要针对这些请求做一些额外附加的事情，这些事情其实用户并不关心或者用户不需要立即拿到这些事情的处理结果，这种情况就比较适合用异步的方式处理这些事情；
    - 4.1 开辟新线程或使用线程池；
    - 4.2 引入 Blockingqueue： 如果异步线程处理的任务涉及的数据量非常巨大，那么可以引入阻塞队列BlockingQueue作进一步的优化。具体做法是让一批异步线程不断地往阻塞队列里扔数据，然后额外起一个处理线程，循环批量从队列里拿预设大小的一批数据，来进行批处理（比如发一个批量的远程服务请求），这样进一步提高了性能
    - 4.3 引入 MQ

5. JVM 调优：
    - 5.1 如果发现高峰期CPU使用率与Load值偏大，这个时候可以观察一些JVM的thread count以及gc count（可能主要是young gc count），如果这两个值都比以往偏大（也可以和一个历史经验值作对比），基本上可以定位是young gc频率过高导致，这个时候可以通过适当增大young区大小或者占比的方式来解决。
    - 5.2 如果发现关键接口响应时间很慢，可以结合gc time以及gc log中的stop the world的时间，看一下整个应用的stop the world的时间是不是比较多。如果是，可能需要减少总的gc time，具体可以从减小gc的次数和减小单次gc的时间这两个维度来考虑，一般来说，这两个因素是一对互斥因素，我们需要根据实际的监控数据来调整相应的参数（比如新生代与老生代比值、eden与survivor比值、MTT值、触发cms回收的old区比率阈值等）来达到一个最优值。
    - 5.3 如果发生full gc或者old cms gc非常频繁，通常这种情况会诱发STW的时间相应加长，从而也会导致接口响应时间变慢。这种情况，大概率是出现了“内存泄露”，Java里的内存泄露指的是一些应该释放的对象没有被释放掉（还有引用拉着它）。那么这些对象是如何产生的呢？为啥不会释放呢？对应的代码是不是出问题了？问题的关键是搞明白这个，找到相应的代码，然后对症下药。所以问题的关键是转化成寻找这些对象。怎么找？综合使用jmap和MAT，基本就能定位到具体的代码

6. 度量系统： 严格来说，度量系统不属于性能优化的范畴，但是这方面和性能优化息息相关，可以说为性能优化提供一个强有力的数据参考和支撑。没有度量系统，基本上就没有办法定位到系统的问题，也没有办法有效衡量优化后的效果。很多人不重视这方面，但我认为它是系统稳定性和性能保障的基石。度量系统基本包括：确定度量指标、数据收集、数据传输、数据存储、数据分析和数据展现这几个环节；