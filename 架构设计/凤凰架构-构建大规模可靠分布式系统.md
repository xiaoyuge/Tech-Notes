# **前言**

如果提起周志明老师所著的 **《深入Java虚拟机》** 这本书，想必从事Java开发的同学应该听过甚至读过。这本书我是在刚参加工作的第一年利用国庆假期的时间精读了一遍，一下子打开了我理解Java世界底层运行机制的大门，在此基础上去学习和应用其他的Java技术总觉得自己像修炼过内力一样，无往而不利。最近偶尔搜索了一下这本书，发现竟然出版到了第四版，我当时学习的还是第一版，可见这本书受欢迎的程度。

但今天我们聊的不是这本书，而是周志明老师2021年出版的 **《凤凰架构-构建可靠的大型分布式系统》**，这本书我是在2022年上半年读的，从这两本书就可以看出，周志明老师的知识真是兼具深度和广度。这本书的封面是长这样的：

![phoenix-arch]()

封面上一只浴火重生的凤凰跃然纸上，也正贴合了这本书从头到尾一以贯之的主题：**涅槃重生**。

## **本书核心观点解读**

为什么要介绍并解读一下这本书？坦白讲，如今市面上讲分布式系统和架构的书太多了，但大多数此类书多是把市面上关于分布式系统的通用知识点简单拼凑，缺乏独到观点，而且偏理论不落地。

周志明老师的这本书让我读完觉得眼前一亮的有两点：

- 通过凤凰涅槃重生的概念，来纠正对于大规模系统可靠性的通俗认知，并通过分布式架构的演进历史和分布式架构运行时的各种可靠性方案来不断强化和说明这一点；

- 不仅有理论还有实践，在GitHub上分别建立了基于SpringBoot、SpringCloud、Kubernetes、Istio和AWSLambda的五种架构风格的样例工程；

本书抛出的一个核心问题是：为了得到高质量的软件产品，我们是应该把精力更多地集中在提升其中每一个人员、过程、产出物的能力和质量上？还是应该把更多精力放在整体流程和架构上？

对这个问题，书中给出的观点是：

- 在“墨菲定律”和在“大规模”这个前提下必然会遇到各种“不靠谱”的人员、代码、硬件、网络等因素，从中能得出一个听起来颇为合理的推论：如果一项工作要经过多个“不靠谱”的过程相互协作完成，其中的误差应会不断累积叠加，导致最终结果必然不能收敛稳定，也即不可能用一些“不可靠”部件构造出一个可靠的系统；

- 生命系统之所以可靠，恰是因为它可以使用“不可靠”部件来完成遗传迭代。这其中的关键点便是承认细胞等零部件可能会出错，某个具体的零部件可能会崩溃消亡，但在存续生命的微生态系统中其后代一定会出现，重新代替该零部件，实现它的作用，以维持系统的整体稳定。在这个微生态里，每一个部件都可以看作一只“不死鸟”（Phoenix），它会老迈，又能涅槃重生；

- 架构演变最重要的驱动力，或者说这种“从大到小”的变化趋势的最根本驱动力，始终都是为了方便某个服务能够顺利地“死去”与“重生”，个体服务的生死更迭，是关系到整个系统能否可靠存续的关键因素；

- 流水不腐。有老朽，有消亡，有重生，有更迭，才是生态运行的合理规律。如果你的系统中的每个部件都符合“Phoenix”的特性，哪怕其中某些部件采用了由“极不靠谱”的人员所开发的“极不靠谱”的程序，哪怕存在严重的内存泄漏问题，哪怕最多只能服务三分钟就会崩溃，只要在整体架构设计有恰当且自动化的错误熔断、服务淘汰和重建机制，从系统外部来观察，架构仍然有可能表现出稳定和健壮的服务能力；

对于软件产品的质量保障，我们常规的做法是：

- 通过培训、分享、老带新等手段，去提高每个人员的技能水平，包括但不限于开发的编程水平，QA的测试水平等，来尽量保证人不要犯错；

- 从需求到设计、开发、测试、上线、运维等整个软件生命周期各个环节，制定各种制度、使用各种工具，来保证各阶段产出物和最终产品的质量不要出错；

这样做有错吗？其实也没错。

但是在软件工程里，任何产品的研发，如果持续时间很长，人总免不了疏忽、犯错，导致代码存在缺陷，电脑宕机崩溃，网络堵塞中断等等。。。如果一项工程需要大量的人员共同研发某个大规模的软件产品，并使其分布在网络中的大量的服务器节点中同时运行，随着项目规模增大、运作时间变长，其必然会受到墨菲定律的无情打击。

但不是说前者不重要，这两者都重要，只是：

- 前者重术，后者重道；
- 前者更多与编码能力相关，后者更多与软件架构相关；
- 前者主要由开发者个体的水平决定，后者主要由技术决策者的水平决定；

也即，通过道，能弥补术的欠缺，通过架构，能规避人的不足。

书中也提到，这两者其实是东西方文化理念的差异：

- 东方人的骨子里更注重的还是一次把事做对、做好，尽量别出乱子；

- 而西方人则要“更看得开”一些，把出错看作正常甚至是必需的发展过程，只要出了问题能够兜底使其重回正轨便好；

## **我的思考总结**

对于以上的核心观点，我个人的理解和总结是：

- 架构本身不是一次性设计出来的，而是不断演进的结果，不要指望一次性把架构设计对，而是要考虑持续的架构演进来满足实际业务场景的需求，比如从单体到微服务到无服务的架构演进，再比如微服务拆分的不合理需要持续拆分重组的演进，此谓架构设计的涅槃重生；

- 分布式架构中的每一个服务节点，也不是一次性就能完美实现并运行，比如代码写的有问题导致内存泄露、线程数飙升，服务可能会出现问题而宕机，但这个没关系，我们只要保证服务节点出现问题有容错机制可以兜底即可，此谓架构运行时的涅槃重生；

所以，接下来，我会从架构设计演进和架构运行时两个方面来分别介绍。

## **架构设计演进的涅槃重生**

### **分布式架构的演进**

本书一开始花了很多篇幅介绍了分布式架构的演进史，在介绍历史之前，作者先抛出了一个他对分布式架构演变最重要的驱动力是什么的观点，其认为从单体到微服务到无服务这种“从大到小”的变化趋势的最根本驱动力，始终都是为了方便某个服务能够顺利地“死去”与“重生”。

Chris Richardson在《微服务架构设计模式》这本书中，列出了单体架构存在的诸多问题，这也是业界理解为什么要拆分单体架构的通俗原因，包括：

1. **代码难以理解和维护**：所有代码揉在一个代码库，代码变得越来越庞大，越来越难以理解，导致开发者面对新需求或问题的修改越来越困难，容易引入Bug，并逐渐导致背离原有架构原则、设计模式等，使得架构越来越腐化；
2. **代码编辑+构建+运行周期变长**：代码越来越多，导致开发过程中IDE响应变慢，构建一次的时间也越来越（编译时间、跑单测时间等），启动一次的时间也越来越长、最终导致每一次程序的小修改都导致部署到生产环境的时间越来越长；
3. **上线部署困难**：当越来越多的团队工作在一个代码库上的时候，无论是主干上线还是拉功能分支上线，都使得想快速上线变得非常困难；
4. **部署资源要求冲突**：随着功能模块越来越多，不同模块的部署资源需求冲突也越来越多，有的模块可能需要部署在有更大内存的服务器上，有的模块可能需要部署在有高性能CPU的服务器上；
5. **故障隔离性差**:多个不同模块因为在一个应用进程内，某个模块的代码错误导致的问题比如内存泄露、线程数飙升等，可能导致整个应用崩溃；
6. **应用新技术难**：不同的功能模块可能更适合采用新的技术语言或框架，但单体架构下必须使用一套技术体系；

但《凤凰架构》认为，对于小型系统，单台机器就足以支撑其良好运行的系统，不仅易于开发、测试、部署，且由于系统中各个功能、模块、方法的调用过程都是进程内调用，不会发生进程间通信（InterProcessCommunication，IPC），因此连运行效率也是最高的，所以当单机性能足够的时候，单体架构完全不应该被贴上“反派角色”的标签。

单体系统的不足，必须在软件的性能需求超过了单机、软件的开发人员规模明显超过了“2PizzaTeam”范畴的前提下才有讨论的价值。

但《微服务架构设计模式》列出的那些问题，都还不是今天以微服务取代单体系统成为潮流趋势的根本原因，《凤凰架构》认为最重要的原因是：单体系统很难兼容“Phoenix”的特性。因为这种架构风格潜在的要求是希望系统的每一个部件、每一处代码都尽量可靠，尽量不出或少出缺陷。单体系统靠高质量来保证高可靠性的思路，在小规模软件上还能运作良好，但当系统规模越来越大时，交付一个可靠的单体系统就变得越来越具有挑战性。

随着软件架构演进，构建可靠系统的观念从“追求尽量不出错”到正视“出错是必然”的转变，这才是微服务架构得以挑战并逐步取代单体架构的底气所在。

为了允许程序出错，获得自治与隔离的能力，以及实现可以技术异构等目标，才是单体拆分为微服务架构的理由。

因此，随着软件规模的扩大，为了软件各个组成部分能够分别互不影响的涅槃重生，推动了从单体架构到分布式架构的演进。

而从单体到微服务1.0到微服务2.0（Service Mesh）的架构演进，自始至终在做的一件事情就是，把服务间通信涅槃重生这件事情做的对应用开发越来越透明。

服务间通讯因为要依赖网络，而网络本质是不可靠的，所以按照凤凰架构的理念，我们要能接受网络的不可靠所带来的服务间通讯的不可靠，而不是去想尽办法优化网络保证稳定。当网络出现各种问题的时候，我们只要有手段能让服务间通讯及时恢复即可，比如重试、限流、熔断、降级等手段，而从单体到微服务1.0再到微服务2.0（Service Mesh）的演进，让服务通讯的涅槃重生逐渐被更底层的基础设施所接管，从而对开发者越来越透明。

### **DDD架构的拆分重组**

其实这部分内容是我自己的感悟，并不是《凤凰架构》这本书中的内容。因为在看这本书的过程中，我想到了之前看过的DDD，DDD对领域模型逻辑边界的定义以及映射到代码目录结构时候对物理边界的定义，正是为了业务变化时候方便的对微服务进行重新拆分重组。

也即，当业务变化的时候，DDD能够让我们的微服务能够方便地进行涅槃重生。

这是因为，DDD设计过程梳理出了三个边界

- **逻辑边界**：**微服务内聚合之间的边界是逻辑边界**。它是一个虚拟的边界，强调业务的内聚，可根据需要变成物理边界，也就是说聚合也可以独立为微服务；
- **物理边界**：**微服务之间的边界是物理边界**。它强调微服务部署和运行的隔离，关注微服务的服务调用、容错和运行等；
- **代码边界**：**不同层或者聚合之间代码目录的边界是代码边界**。它强调的是代码之间的隔离，方便架构演进时代码的重组；

通过以上边界，我们可以让业务能力高内聚、代码松耦合，且清晰的边界，可以快速实现微服务代码的拆分和组合，轻松实现微服务架构演进。随着需求或设计变化，领域模型会迭代，微服务的代码也会分分合合，边界清晰的微服务，可快速实现微服务代码的重组

如果在微服务设计之初按照 DDD 的战略设计方法，定义好了微服务内的逻辑边界，做好了架构的分层，其实我们不必拆分太多的微服务，即使是单体也未尝不可。随着技术积累和能力提升，当我们有了这些能力后，由于应用内有清晰的逻辑边界，我们可以随时轻松地重组出新的微服务，而这个过程也不会花费太多的时间和精力

### **架构运行时的涅槃重生**

这个主要指微服务服务实例运行出错时候的涅槃重生问题。

单体被拆分为微服务，让服务涅槃重生这件事变得更加独立可控。

而且，随着容器、K8s、serverless等云原生基础设施的出现，逐渐把微服务涅槃重生这件事做的对应用开发者越来越透明。

比如容器因为打包了应用所依赖的所有底层环境，提供了对于运行环境的极强适应性和快速启动的能力，开发者不需要再关注不同环境的差异性

比如k8s所代表的不可变基础设施，可以在pod部署时提供更多的一致性和可靠性，以及更简单、更可预测的部署过程，开发者不需要再关注复杂的服务器配置差异问题

比如声明式API可以实现服务故障时候的自动恢复、服务升级时的自动滚动更新以及服务遇到瞬时高峰压力时候的自动水平扩容，开发者只需要声明即可

而Serverless则更近一步，所谓“无服务器”就是想让用户感觉不到服务器的存在，开发者可以完全专注于业务逻辑的编写，而不再关心任何基础设施，完全屏蔽了计算资源，是在真正地引导你不再去关心底层环境，你只要遵循标准方式来直接编写业务代码就可以了

更详细的内容，可以去看我的另外一篇文章[《云原生、Serverless和Low-Code是程序员挥刀自宫的那把刀吗》](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E4%BA%91%E5%8E%9F%E7%94%9F/%E4%BA%91%E5%8E%9F%E7%94%9F%E3%80%81Serverless%E5%92%8CLow-Code%E6%98%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8C%A5%E5%88%80%E8%87%AA%E5%AE%AB%E7%9A%84%E9%82%A3%E6%8A%8A%E5%88%80%E5%90%97.md)


## **人生如斯，亦可涅槃重生**

如上，就是《凤凰架构》这本书的核心主线内容以及我的个人解读。除此之外，这本书还对RPC调用的实现原理、RPC与REST的对比分析、分布式服务的基石（共识算法、服务发现、网关路由、流量治理、零信任网络）、从浏览器到DNS到CDN到负载均衡的多级分流系统等进行了详细的介绍，其讲解的内容也不同于其他书，不仅让你知其然，还让你知其所以然，还是非常值得一读的。

最后，我想说的是，我们的人生何尝不和架构一样，不会被一次性定义，我们也可以不断调整并适应新的环境，不断提升和演进自己的能力，从而让我们在面对一次次的困境的时候，也能够涅槃重生。

祝大家都能够成为不死鸟一辉！