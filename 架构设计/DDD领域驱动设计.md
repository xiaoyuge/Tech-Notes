## **DDD（Domain Driven Design，领域驱动设计）**

DDD示例代码见：[示例代码](https://github.com/xiaoyuge/leave-microservice)

### **领域模型**

**业务软件开发的核心难度在于处理隐藏在业务知识中的复杂度**，那么**模型就是对这种复杂度的简化与精炼**。所以从某种意义上说，Eric倡导的领域驱动设计是一种模型驱动的设计方法：**通过领域模型（Domain Model）捕捉领域知识**，使用领域模型构造更易维护的软件。

**开发人员面对业务需求或问题的时候，习惯于直接将业务需求或问题转换为数据结构+算法这样的模型**，而这样的模型业务方并不熟悉，无法直观映射为他们更为熟悉的业务流程和功能，这种认知上的差异，会造成团队沟通的困难，从而破坏统一语言的形成，加剧知识传递的难度。

于是在业务系统中，构造一种专用的模型（领域模型），将相关的业务流程与功能转化成模型的行为，就能避免开发人员与业务方的认知差异。这也是为什么我们讲，领域模型对于业务系统是一种更好的选择。

### **统一语言**

DDD 方法论在系统建模过程中，可以为团队中的各个角色提供一套“统一语言”，避免组件划分过程中的边界错位，完成领域图预演、需求分析、架构模型、代码模型、测试等工作。

“统一语言”的概念在 DDD 中极为重要，因为在一个系统的构建过程中，往往**业务人员关注的是业务架构，而技术人员则关注系统架构的表述方式**。这就导致在将业务架构映射到系统架构的时候，需要经过一层“翻译”工作，这就会使工作变得复杂、低效。

在 DDD 中，只要使用一个“统一语言”，就可以直接将业务架构与系统架构绑定，不需要进一步去翻译，从而增强系统对业务的响应速度

在事件风暴过程中，**通过团队交流达成共识的，能够简单、清晰、准确描述业务涵义和规则的语言就是统一语言**。也就是说，不管你在团队中承担什么角色，在同一个领域的软件生命周期里都使用统一的语言进行交流。

统一语言包含术语和用例场景，并且能够直接反映在代码中。**统一语言中的名词可以给领域对象命名，如商品、订单等，对应实体对象；而动词则表示一个动作或事件，如商品已下单、订单已付款等，对应领域事件或者命令**。统一语言贯穿 DDD 的整个设计过程。作为项目团队沟通和协商形成的统一语言，基于它，你就能够开发出可读性更好的代码，将业务需求准确转化为代码设计

事件风暴过程中讨论形成统一语言和领域模型，且统一语言中的名词是领域模型中的领域对象名，统一语言中的动词是领域模型中的命令或事件。

### **问题域和解决方案域**

DDD 的中文翻译“领域驱动设计”中的“领域”一词指的是要实现的软件系统所要解决的实际问题所处的整个领域范围，它不仅包括系统架构的相关问题，还涉及到系统所支持的业务等内容，但它是与具体的开发技术无关的。也就是说 DDD 关注的是要构建的系统中，关于所要解决的问题的业务、流程和数据等内容是如何工作的，在这些东西理清之后，DDD 去构建出一个模型，接着再去选择具体的实现技术。DDD 强调的是解耦具体实现技术，所以它可以迅速梳理核心业务逻辑

### **DDD的一个生命周期**

在设计和实现一个系统的时候，这个系统所要处理问题的领域专家和开发人员以一套统一语言进行协作，共同完成该领域模型的构建，在这个过程中，业务架构和系统架构等问题都得到了解决，之后将领域模型中关于系统架构的主体映射为实现代码，完成系统的实现落地。而用什么方式去做领域模型的构建，方法是多样的，Alberto 自己就为此发明了 Event Storming（事件风暴），并成为了一种经典的 DDD 落地模式

### **中台v微服务vsDDD**

中台本质是业务模型，微服务是业务模型的系统落地，**DDD 是一种设计思想，它可以同时指导中台业务建模和微服务设计**，它们之间就是这样的一个铁三角关系。DDD 强调领域模型和微服务设计的一体性，先有领域模型然后才有微服务，而不是脱离领域模型来谈微服务设计

DDD 是一种处理高度复杂领域的设计思想，它试图分离技术实现的复杂性，并围绕业务概念构建领域模型来控制业务的复杂性，以解决软件难以理解，难以演进的问题。**DDD不是架构，而是一种架构设计方法论**，它通过边界划分将复杂业务领域简单化，帮我们设计出清晰的领域和应用边界，可以很容易地实现架构演进

DDD 包括 战略设计 和 战术设计 两部分。

- **战略设计（业务域->领域模型）**：主要从业务视角出发，建立业务领域模型，划分领域边界，建立通用语言的限界上下文，限界上下文可以作为微服务设计的参考边界；
- **战术设计（领域模型->代码逻辑）**：则从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地，包括：聚合根、实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现

### **限界上下文**

限界上下文拆解为两个词：限界和上下文。限界就是领域的边界，而上下文则是语义环境。通过领域的限界上下文，我们就可以**在统一的领域边界内用统一的语言进行交流**

所以，限界上下文的定义就是：用来封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性

语言离不开它的语义环境，业务的通用语言就有它的业务边界，我们不大可能用一个简单的术语没有歧义地去描述一个复杂的业务领域。限界上下文就是用来细分领域，从而定义通用语言所在的边界

中文这门语言非常丰富，在不同的时空和背景下（即不同的限界上下文），同样的一句话会有不同的涵义，举个例子：
比如一个杯子，在工厂设计和生产时候叫产品，在门店或电商销售的时候叫商品，当购买后放在家里使用的时候叫居家用品，当不用了丢弃的时候叫废品。

DDD 战略设计会建立领域模型，领域模型可以用于指导微服务的设计和拆分
事件风暴是建立领域模型的主要方法，它是一个**从发散到收敛**的过程：

- **发散**：它通常采用**用例分析、场景分析和用户旅程分析**，尽可能全面不遗漏地分解业务领域，并梳理领域对象之间的关系，这是一个发散的过程；
- **收敛**：事件风暴过程会产生很多的实体、命令、事件等领域对象，我们将这些领域对象从不同的维度进行聚类，形成如聚合、限界上下文等边界，建立领域模型，这就是一个收敛的过程；

![domain-model](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/domain-model.png)

### **DDD的设计过程**

我们可以用三步来划定领域模型和微服务的边界：

- 第一步：在事件风暴中梳理业务过程中的用户操作、事件以及外部依赖关系等，根据这些要素梳理出领域实体等领域对象；
- 第二步：根据领域实体之间的**业务关联性**，将业务紧密相关的实体进行组合形成聚合，同时确定聚合中的聚合根、值对象和实体。在上面那个图里，**聚合之间的边界是第一层边界，它们在同一个微服务实例中运行**，这个边界是逻辑边界，所以用虚线表示；
- 第三步：根据业务及语义边界等因素，将一个或者多个聚合划定在一个限界上下文内，形成领域模型。在这个图里，限界上下文之间的边界是第二层边界，这一层边界可能就是未来微服务的边界，**不同限界上下文内的领域逻辑被隔离在不同的微服务实例中运行，物理上相互隔离，所以是物理边界**，边界之间用实线来表示

### **我的思考**

1. 软件设计有一个原则是【高内聚，低耦合】，即模块内高内聚，模块之间低耦合，这里的模块就是一种划分代码结构的方法；

2. 而微服务也是一种在更高的层面划分代码架构的方法，ok，那如何让划分的微服务做到高内聚低耦合？

3. 高内聚低耦合的好处是，内聚的都是某个业务领域紧密相关的代码，而不同业务领域的代码被物理隔离，这样的好处是，**当某个业务领域发生变化的时候，所有修改都发生在一处**，而不会发生在多处；

4. 所以，DDD的领域模型，就是在划分不同的业务领域边界，让相同业务领域的实体能够聚合在一起，如果微服务的拆分边界也参照领域模型的边界，那么就能够在业务变化的时候，以最低的成本进行适应；

DDD是一种架构设计方法，微服务是一种架构风格，两者从本质上都是为了追求高响应力，而从业务视角去分离应用系统建设复杂度的手段。

两者都强调从业务出发，其核心要义是强调根据业务发展，合理划分领域边界，持续调整现有架构，优化现有代码，以保持架构和代码的生命力，也就是我们常说的演进式架构。

DDD 主要关注：从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。

微服务主要关注：运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署

在领域不断划分的过程中，领域会细分为不同的子域，子域可以根据自身重要性和功能属性划分为三类子域，它们分别是：核心域、通用域和支撑域。

- **核心域**：决定产品和公司核心竞争力的子域是核心域，它是业务成功的主要因素和公司的核心竞争力；
- **通用域**：没有太多个性化的诉求，同时被多个子域使用的通用功能子域是通用域，比如认证、权限等；
- **支撑域**：还有一种功能子域是必需的，但既不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域，它就是支撑域，例如数据代码类的数据字典等系统；

很多公司的业务，表面看上去相似，但商业模式和战略方向是存在很大差异的，因此公司的关注点会不一样，在划分核心域、通用域和支撑域时，其结果也会出现非常大的差异

商业模式的不同会导致核心域划分结果的不同。有的公司核心域可能在客户服务，有的可能在产品质量，有的可能在物流。在公司领域细分、建立领域模型和系统建设时，我们就要结合公司战略重点和商业模式，找到核心域了，且重点关注核心域

建议你和你的技术团队要将核心域的建设排在首位，最好是有绝对的掌控能力和自主研发能力，如果资源实在有限的话，可以在支撑域或者通用域上想想办法，暂时采用外购的方式也未尝不可

每个领域模型都有它对应的限界上下文，团队在限界上下文内用通用语言交流。领域内所有限界上下文的领域模型构成整个领域的领域模型。

**理论上限界上下文就是微服务的边界**。我们将限界上下文内的领域模型映射到微服务，就完成了从问题域到软件的解决方案。

可以说，限界上下文是微服务设计和拆分的主要依据。在领域模型中，如果不考虑技术异构、团队沟通等其它外部因素，一个限界上下文理论上就可以设计为一个微服务。

### **实体和值对象**

实体和值对象是组成领域模型的基础单元

#### **实体的业务形态**

在 DDD 不同的设计过程中，实体的形态是不同的。在战略设计时，实体是领域模型的一个重要对象。领域模型中的实体是多个属性、操作或行为的载体。在事件风暴中，我们可以根据命令、操作或者事件，找出产生这些行为的业务实体对象，进而按照一定的业务规则将依存度高和业务关联紧密的多个实体对象和值对象进行聚类，形成聚合

#### **实体的代码形态**

在代码模型中，实体的表现形式是实体类，这个类包含了实体的属性和方法，通过这些方法实现实体自身的业务逻辑。**在 DDD 里，这些实体类通常采用充血模型**，与这个实体相关的所有业务逻辑都在实体类的方法中实现，跨多个实体的领域逻辑则在领域服务中实现。

#### **实体的运行形态**

实体以 DO（领域对象）的形式存在，每个实体对象都有唯一的 ID。我们可以对一个实体对象进行多次修改，修改后的数据和原来的数据可能会大不相同。但是，由于它们拥有相同的 ID，它们依然是同一个实体

#### **值对象**

值对象是 DDD 领域模型中的一个基础对象，它跟实体一样都来源于事件风暴所构建的领域模型，都包含了若干个属性，它与实体一起构成聚合

实体是看得到、摸得着的实实在在的业务对象，实体具有业务属性、业务行为和业务逻辑。

而值对象只是若干个属性的集合，只有数据初始化操作和有限的不涉及修改数据的行为，基本不包含业务逻辑。值对象的属性集虽然在物理上独立出来了，但在逻辑上它仍然是实体属性的一部分，用于描述实体的特征

### **聚合和聚合根**

在事件风暴中，我们会根据一些业务操作和行为找出实体（Entity）或值对象（ValueObject），进而将业务关联紧密的实体和值对象进行组合，构成聚合，再根据业务语义将多个聚合划定到同一个限界上下文（Bounded Context）中，并在限界上下文内完成领域建模

在 DDD 中，实体和值对象是很基础的领域对象。实体一般对应业务对象，它具有业务属性和业务行为；而值对象主要是属性集合，对实体的状态和特征进行描述。但实体和值对象都只是个体化的对象，它们的行为表现出来的是个体的能力

领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性

聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化

聚合有一个聚合根和上下文边界，这个边界根据业务单一职责和高内聚原则，定义了聚合内部应该包含哪些实体和值对象，而聚合之间的边界是松耦合的。按照这种方式设计出来的微服务很自然就是“高内聚、低耦合”的

聚合在 DDD 分层架构里属于领域层，领域层包含了多个聚合，共同实现核心业务逻辑。聚合内实体以充血模型实现个体业务能力，以及业务逻辑的高内聚。跨多个实体的业务逻辑通过领域服务来实现，跨多个聚合的业务逻辑通过应用服务来实现

#### **聚合根**

聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题

如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者

首先它作为实体本身，拥有实体的属性和业务行为，实现自身的业务逻辑。
其次它作为聚合的管理者，在聚合内部负责协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑。

最后在聚合之间，它还是聚合对外的接口人，以聚合根 ID 关联的方式接受外部任务和请求，在上下文内实现聚合之间的业务协同。也就是说，聚合之间通过聚合根 ID 关联引用，如果需要访问其它聚合的实体，就要先访问聚合根，再导航到聚合内部实体，外部对象不能直接访问聚合内实体

### **如何设计聚合?**

DDD 领域建模通常采用事件风暴，它通常采用用例分析、场景分析和用户旅程分析等方法，通过头脑风暴列出所有可能的业务行为和事件，然后找出产生这些行为的领域对象，并梳理领域对象之间的关系，找出聚合根，找出与聚合根业务紧密关联的实体和值对象，再将聚合根、实体和值对象组合，构建聚合

判断一个实体是否是聚合根，你可以结合以下场景分析：

- 是否有独立的生命周期？
- 是否有全局唯一ID？
- 是否可以创建或修改其它对象？
- 是否有专门的模块来管这个实体

### **领域事件**

领域事件是领域模型中非常重要的一部分，用来表示领域中发生的事件。一个领域事件将导致进一步的业务操作，在实现业务解耦的同时，还有助于形成完整的业务闭环

### **如何识别领域事件**

在做用户旅程或者场景分析时，我们要捕捉业务、需求人员或领域专家口中的关键词：“如果发生……，则……”“当做完……的时候，请通知……”“发生……时，则……”等。在这些场景中，如果发生某种事件后，会触发进一步的操作，那么这个事件很可能就是领域事件

### **聚合的一个设计原则**

在边界之外使用最终一致性。一次事务最多只能更改一个聚合的状态。如果一次业务操作涉及多个聚合状态的更改，应采用领域事件的最终一致性

领域事件驱动设计可以切断领域模型之间的强依赖关系，事件发布完成后，发布方不必关心后续订阅方事件处理是否成功，这样可以实现领域模型的解耦，维护领域模型的独立性和数据的一致性。在领域模型映射到微服务系统架构时，领域事件可以解耦微服务，**微服务之间的数据不必要求强一致性，而是基于事件的最终一致性**

### **微服务内的领域事件**

微服务内大部分事件的集成，都发生在同一个进程内，**进程自身可以很好地控制事务，因此不一定需要引入消息中间件**。但一个事件如果同时更新多个聚合，按照 **DDD“一次事务只更新一个聚合”的原则**，你就要考虑是否引入事件总线。

但微服务内的事件总线，可能会增加开发的复杂度，因此你需要结合应用复杂度和收益进行综合考虑。

微服务内应用服务，可以通过跨聚合的服务编排和组合，以服务调用的方式完成跨聚合的访问，这种方式通常应用于实时性和数据一致性要求高的场景。这个过程会用到分布式事务，以保证发布方和订阅方的数据同时更新成功

### **微服务之间的领域事件**

跨微服务的事件机制要总体考虑事件构建、发布和订阅、事件数据持久化、消息中间件，甚至事件数据持久化时还可能需要考虑引入分布式事务机制等。

微服务之间的访问也可以采用应用服务直接调用的方式，实现数据和服务的实时访问，弊端就是跨微服务的数据同时变更需要引入分布式事务，以确保数据的一致性。分布式事务机制会影响系统性能，增加微服务之间的耦合，所以我们还是要尽量避免使用分布式事务。

### **领域事件总体架构（EDA（Event Driven Architecture，事件驱动架构））**

领域事件处理包括：

- 事件构建和发布
- 事件数据持久化
- 事件总线
- 消息中间件
- 事件接收和处理

![eda-arch](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/EDA-Arch.png)

个人觉得：方案2更合适，业务表和事件表在一个数据库，可以使用数据库本地事务保证业务操作和事件发送的强一致性

1. **事件构建和发布**

   事件基本属性至少包括：事件唯一标识、发生时间、事件类型和事件源，其中事件唯一标识应该是全局唯一的，以便事件能够无歧义地在多个限界上下文中传递。事件基本属性主要记录事件自身以及事件发生背景的数据。

   另外事件中还有一项更重要，那就是业务属性，用于记录事件发生那一刻的业务数据，这些数据会随事件传输到订阅方，以开展下一步的业务操作。

   事件基本属性和业务属性一起构成事件实体，事件实体依赖聚合根。领域事件发生后，事件中的业务数据不再修改，因此业务数据可以以序列化值对象的形式保存，这种存储格式在消息中间件中也比较容易解析和获取。

   为了保证事件结构的统一，我们还会创建事件基类 DomainEvent（参考下图），子类可以扩充属性和方法。由于事件没有太多的业务行为，实现方法一般比较简单

   ![DomainEvent](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/DomainEvent.png)

   事件发布之前需要先构建事件实体并持久化。事件发布的方式有很多种，你可以通过应用服务或者领域服务发布到事件总线或者消息中间件，也可以从事件表中利用定时程序或数据库日志捕获技术获取增量事件数据，发布到消息中间件

2. **事件数据持久化**

   事件数据持久化可用于系统之间的数据对账，或者实现发布方和订阅方事件数据的审计。当遇到消息中间件、订阅方系统宕机或者网络中断，在问题解决后仍可继续后续业务流转，保证数据的一致性。

   事件数据持久化有两种方案，在实施过程中你可以根据自己的业务场景进行选择：
   1. 持久化到本地业务数据库的事件表中，利用本地事务保证业务和事件数据的一致性；

   2. 持久化到共享的事件数据库中。这里需要注意的是：业务数据库和事件数据库不在一个数据库中，它们的数据持久化操作会跨数据库，因此需要分布式事务机制来保证业务和事件数据的强一致性，结果就是会对系统性能造成一定的影响；

   个人觉得：方案1更合适

3. **事件总线 (EventBus)**

   **事件总线是实现微服务内聚合之间领域事件的重要组件**，它提供事件分发和接收等服务。**事件总线是进程内模型**，它会在微服务内聚合之间遍历订阅者列表，采取同步或异步的模式传递数据。事件分发流程大致如下：
   1. 如果是微服务内的订阅者（其它聚合），则直接分发到指定订阅者；
   2. 如果是微服务外的订阅者，将事件数据保存到事件库（表）并异步发送到消息中间件；
   3. 如果同时存在微服务内和外订阅者，则先分发到内部订阅者，将事件消息保存到事件库（表），再异步发送到消息中间件；

4. **消息中间件**

   跨微服务的领域事件大多会用到消息中间件，实现跨微服务的事件发布和订阅。消息中间件的产品非常成熟，市场上可选的技术也非常多，比如 Kafka，RabbitMQ 等

5. **事件接收和处理**

   微服务订阅方在应用层采用监听机制，接收消息队列中的事件数据，完成事件数据的持久化后，就可以开始进一步的业务处理。领域事件处理可在领域服务中实现

领域事件运行机制相关案例

![domain-event-runtime-case](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/domain-event-runtime-case.png)

领域事件是 DDD 的一个重要概念，在设计时我们要重点关注领域事件，**用领域事件来驱动业务的流转，尽量采用基于事件的最终一致**，降低微服务之间直接访问的压力，实现微服务之间的解耦，维护领域模型的独立性和数据一致性。

### **DDD分层架构**

![DDD-4-level-arc](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/DDD-4-level-arch.png)

#### **DDD四层架构包括**

1) **用户接口层**

   负责向用户显示信息和解释用户指令，这里的用户可能是：用户、程序、自动化测试和批处理脚本等等

2) **应用层：**
   1. 应用层是很薄的一层，理论上不应该有业务规则或逻辑，主要面向用例和流程相关的操作，**不要将本该放在领域层的业务逻辑放到应用层中实现**。因为庞大的应用层会使领域模型失焦，时间一长你的微服务就会演化为传统的三层架构，业务逻辑会变得混乱；

   2. 应用层位于领域层之上，因为领域层包含多个聚合，所以它可以协调多个聚合的服务和领域对象完成服务编排和组合，协作完成业务操作；

   3. 应用层也是**微服务之间交互的通道**，它可以调用其它微服务的应用服务，完成微服务之间的服务组合和编排；

   4. 应用服务是在应用层的，它负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装，以粗粒度的服务通过 API 网关向前端发布；

   5. 应用服务还可以进行**安全认证、权限校验、事务控制、发送或订阅领域事件**等(也即与业务无关的横切关注点)；

3) **领域层：**
   1. 领域层的作用是实现企业核心业务逻辑，通过各种校验手段保证业务的正确性；

   2. 领域层主要体现领域模型的业务能力，它用来表达业务概念、业务状态和业务规则；

   3. 领域层包含聚合根、实体、值对象、领域服务等领域模型中的领域对象；

   4. 领域模型的业务逻辑主要是由实体和领域服务来实现的，其中**实体会采用充血模型**来实现所有与之相关的业务功能。其次，实体和领域服务在实现业务逻辑上不是同级的，当领域中的某些功能，单一实体（或者值对象）不能实现时，领域服务可以组合聚合内的多个实体（或者值对象），实现复杂的业务逻辑；

4) **基础层：**
   1. **贯穿所有层**，作用就是为其它各层提供通用的技术和基础服务，包括第三方工具、驱动、消息中间件、网关、文件、缓存以及数据库等，比较常见的功能还是提供数据库持久化；

   2. 基础层包含基础服务，它**采用依赖倒置设计**，封装基础资源服务，实现应用层、领域层与基础层的解耦，降低外部资源变化对应用的影响；

#### **DDD 分层架构的重要原则**

分层架构分为两种：

1. **严格分层架构**

   **每层只能与位于其下方的层发生耦合**，在严格分层架构模式下，不允许服务的跨层调用，每个服务只能调用它的下一层服务。服务从下到上依次为：实体方法、领域服务和应用服务。在严格分层架构中，服务如果需要跨层调用，下层服务需要在上层封装后，才可以提供跨层服务。比如实体方法需要向应用服务提供服务，它需要封装成领域服务。

   好处：严格分层架构使得程序结构变得清晰，升级和维护更加容易。我们修改某层代码时，只要本层的接口参数不变，其它层可以不必修改。**即使本层的接口发生变化，也只影响相邻的上层，修改工作量小且错误可以控制**，不会带来意外的风险

   如果需要实现服务的跨层调用，建议采用服务逐层封装的方式，如下所示：

   ![servie-pakage-by-level](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/servie-pakage-by-level.png)

2. **松散分层架构**

   在松散分层架构中，领域层的实体方法和领域服务可以直接暴露给应用层和用户接口层。松散分层架构的服务依赖关系，无需逐级封装，可以快速暴露给上层。

   问题：
   - 第一个是容易暴露领域层核心业务的实现逻辑；
   - 第二个是当实体方法或领域服务发生服务变更时，由于服务同时被多层服务调用和组合，不容易找出哪些上层服务调用和组合了它，不方便通知到所有的服务调用方；

#### **三层架构向 DDD 分层架构演进的过程**

1. 三层架构向DDD分层架构演进，主要发生在业务逻辑层和数据访问层；
2. DDD分层架构在用户接口层引入了 DTO，给前端提供了更多的可使用数据和更高的展示灵活性；
3. DDD分层架构对三层架构的业务逻辑层进行了更清晰的划分，**改善了三层架构核心业务逻辑混乱，代码改动相互影响大的情况**。DDD 分层架构将业务逻辑层的服务拆分到了应用层和领域层。**应用层快速响应前端的变化，领域层实现领域模型的能力**；
4. 三层架构数据访问采用 DAO 方式，DDD 分层架构的数据库等基础资源访问，采用了仓储（Repository）设计模式，通过依赖倒置实现各层对基础资源的解耦；
5. 仓储又分为两部分：仓储接口和仓储实现。仓储接口放在领域层中，仓储实现放在基础层。原来三层架构通用的第三方工具包、驱动、Common、Utility、Config 等通用的公共的资源类统一放到了基础层；

#### **微服务代码模型**

只有建立了标准的微服务代码模型和代码规范后，我们才可以将领域对象所对应的代码对象放在合适的软件包的目录结构中。标准的代码模型可以让项目团队成员更好地理解代码，根据代码规范实现团队协作；还可以让微服务各层的逻辑互不干扰、分工协作、各据其位、各司其职，避免不必要的代码混淆。另外，标准的代码模型还可以让你在微服务架构演进时，轻松完成代码重构

微服务代码模型就是依据 DDD 分层架构模型设计出来的

#### **DDD分层架构模型各层的职责**

1. **用户接口层**：面向前端提供服务适配，面向资源层提供资源适配。这一层聚集了**接口适配**相关的功能；
2. **应用层**：实现服务组合和编排，适应业务流程快速变化的需求。这一层聚集了应用服务和事件相关的功能；
3. **领域层**：实现领域的核心业务逻辑。这一层聚集了领域模型的聚合、聚合根、实体、值对象、领域服务和事件等领域对象，以及它们组合所形成的业务能力；
4. **基础层**：贯穿所有层，**为各层提供基础资源服务**。这一层聚集了各种底层资源相关的服务和能力；

#### **微服务一级目录结构**

![icro-service-code-directory](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/micro-service-code-directory.png)

1) **Interfaces（用户接口层）**：

   它主要存放用户接口层与前端交互、展现数据相关的代码。前端应用通过这一层的接口，向应用服务获取展现所需的数据。这一层主要用来处理用户发送的 Restful 请求，解析用户输入的配置文件，并将数据传递给 Application 层。数据的组装、数据传输格式以及 Facade 接口等代码都会放在这一层目录里:

   ![microservice-code-interface](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/microservice-code-interface.png)

   - **Assembler**：实现 DTO 与领域对象之间的相互转换和数据交换。一般来说 Assembler 与 DTO 总是一同出现；
   - **Dto**：它是数据传输的载体，内部不存在任何业务逻辑，我们可以通过 DTO 把内部的领域对象与外界隔离；
   - **Facade**：提供较粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理；

2) **Application（应用层）**：

   它主要存放应用层服务组合和编排相关的代码。应用服务向下基于微服务内的领域服务或外部微服务的应用服务完成服务的编排和组合，向上为用户接口层提供各种应用数据展现支持服务。应用服务和事件等代码会放在这一层目录里:

   ![microservice-code-applicaiton](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/microservice-code-applicaiton.png)

   - **Event（事件）**：这层目录主要存放事件相关的代码。它包括两个子目录：publish 和 subscribe。前者主要存放事件发布相关代码，后者主要存放事件订阅相关代码（事件处理相关的核心业务逻辑在领域层实现）。虽然应用层和领域层都可以进行事件的发布和处理，但为了实现事件的统一管理，**我建议你将微服务内所有事件的发布和订阅的处理都统一放到应用层，事件相关的核心业务逻辑实现放在领域层**。通过应用层调用领域层服务，来实现完整的事件发布和订阅处理流程；

   - **Service（应用服务）**：这层的服务是应用服务。应用服务会对多个领域服务或外部应用服务进行封装、编排和组合，对外提供粗粒度的服务。应用服务主要实现服务组合和编排，是一段独立的业务逻辑。你可以将所有应用服务放在一个应用服务类里，也可以把一个应用服务设计为一个应用服务类，以防应用服务类代码量过大；

3) **Domain（领域层）**：它主要存放领域层核心业务逻辑相关的代码。领域层可以包含多个聚合代码包，它们共同实现领域模型的核心业务逻辑。聚合以及聚合内的实体、方法、领域服务和事件等代码会放在这一层目录里:

   ![microservice-code-domain](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/microservice-code-domain.png)

#### **基于DDD分层的一个微服务的详细代码结构目录**

![microservice-code-details](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/microservice-code-details.png)

- **Aggregate（聚合）**：它是聚合软件包的根目录，可以根据实际项目的聚合名称命名，比如权限聚合。在聚合内定义聚合根、实体和值对象以及领域服务之间的关系和边界。聚合内实现高内聚的业务逻辑，它的代码可以独立拆分为微服务。以聚合为单位的代码放在一个包里的主要目的是为了业务内聚，而更大的目的是为了以后微服务之间聚合的重组；

- **Entity（实体）**：它存放聚合根、实体、值对象以及工厂模式（Factory）相关代码。实体类采用充血模型，同一实体相关的业务逻辑都在实体类代码中实现，跨实体的业务逻辑代码在领域服务中实现；

- **Event（事件）**：它存放事件实体以及与事件活动相关的业务逻辑代码；

- **Service（领域服务）**：它存放领域服务代码。一个领域服务是多个实体组合出来的一段业务逻辑。你可以将聚合内所有领域服务都放在一个领域服务类中，你也可以把每一个领域服务设计为一个类。如果领域服务内的业务逻辑相对复杂，我建议你将一个领域服务设计为一个领域服务类，避免由于所有领域服务代码都放在一个领域服务类中，而出现代码臃肿的问题。领域服务封装多个实体或方法后向上层提供应用服务调用；

- **Repository（仓储）**：它存放所在聚合的查询或持久化领域对象的代码，通常包括仓储接口和仓储实现方法。为了方便聚合的拆分和组合，我们设定了一个原则：一个聚合对应一个仓储；

#### **关于DDD分层代码模型的关键点**

- 第一点：聚合之间的代码边界一定要清晰。聚合之间的服务调用和数据关联应该是尽可能的松耦合和低关联，**聚合之间的服务调用应该通过上层的应用层组合实现调用，原则上不允许聚合之间直接调用领域服务**。这种松耦合的代码关联，在以后业务发展和需求变更时，可以很方便地实现业务功能和聚合代码的重组，在微服务架构演进中将会起到非常重要的作用；

- 第二点：你一定要有代码分层的概念。写代码时一定要搞清楚每层代码目录的职责，将代码放在职责对应的代码目录内。应用层代码主要完成服务组合和编排，以及聚合之间的协作，它是很薄的一层，不应该有核心领域逻辑代码。领域层是业务的核心，领域模型的核心逻辑代码一定要在领域层实现。如果将核心领域逻辑代码放到应用层，基于 DDD 分层架构模型的微服务慢慢就会演变成传统的三层架构模型；

#### **DDD四层分层架构的优势（隔离变化 or 关注点分离）**

分层架构大多是通过前端或后端适配，**逐层控制外部变化向领域层传导，从而降低外部变化对领域层的影响**（领域层应该跟随领域模型变化，而不是跟随前端应用而变化）

个人理解：逐层隔离变化

比如

- 在前端应用中可以消化掉页面逻辑和页面流程类需求；

- 在用户接口层可以完成前端应用接口和数据适配，避免将接口和数据适配类需求传导到应用层；

- 在应用层通过服务组合和编排，可以避免用例或服务组合类需求向领域层传导；

- 在基础设施层通过依赖倒置设计，可以隔离技术组件变化对领域逻辑的影响；

 这样**由外向里逐层消化和隔离外部变化对领域模型的影响**，从而可以最大限度保持领域模型原子性和长期稳定。 一个稳定的领域模型可以给我们带来非常多的好处：

- 首先，领域模型的构建过程是项目团队通用语言建立的过程，领域模型就是团队的通用语言，它会贯穿项目的所有过程；

- 其次，领域模型的业务逻辑大多是可复用的原子逻辑，不易受外部变化的影响。将这些核心逻辑沉淀到领域层，让核心逻辑更聚焦，核心代码更内聚；然后在应用层通过应用服务对领域层服务完成组合和编排，可以大量复用领域层的核心业务逻辑代码，从而提升代码复用率；

- 第三，领域模型的核心代码可交由专门的资深开发人员维护，从而提升代码质量，也能够保证应用关键核心业务逻辑的长期稳定运行；

- 第四，领域模型内聚合边界更加清晰，可方便微服务以聚合为单位的功能和代码的拆分和重组，让微服务具有更强的演进能力；

4. **Infrastructure（基础层）**：

   它主要存放基础资源服务相关的代码，为其它各层提供的通用技术能力、三方软件包、数据库服务、配置和基础资源服务的代码都会放在这一层目录里:

   ![microservice-code-infra](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/microservice-code-infra.png)

   - Config：主要存放配置相关代码；
   - Util：主要存放平台、开发框架、消息、数据库、缓存、文件、总线、网关、第三方类库、通用算法等基础代码，你可以为不同的资源类别建立不同的子目录；

领域模型->微服务代码模型的映射例子

![domainModel-microServiceCode](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/domainModel-microServiceCode.png)

最终形成的微服务代码结构目录

![final-microservice-code-struct](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/final-microservice-code-struct.png)

### **微服务的演进式架构**

微服务的一个重要特征是**演进式架构**，演进式架构就是以支持增量的、非破坏的变更作为第一原则，同时支持在应用程序结构层面的多维度变化

#### **如何判断微服务设计是否合理？**

只需要看它是否满足这样的情形就可以了：随着业务的发展或需求的变更，在不断重新拆分或者组合成新的微服务的过程中，不会大幅增加软件开发和维护的成本，并且这个架构演进的过程是非常轻松、简单的

即微服务设计的重点，是看**微服务设计是否能够支持架构长期、轻松的演进**

DDD 方法设计的微服务，不仅可以通过限界上下文和聚合实现微服务内外的解耦，同时也可以很容易地实现业务功能积木式模块的重组和更新，从而实现架构演进

也即，微服务也可以不用DDD来作为拆分依据和代码结构目录参考，但DDD应该提供了一个如何构建一个可以长期低成本演进的微服务的最佳实践

### **小单体微服务**

有些项目团队在将集中式单体应用拆分为微服务时，首先进行的往往不是建立领域模型，而只是按照业务功能将原来单体应用的一个软件包拆分成多个所谓的“微服务”软件包，而**这些“微服务”内的代码仍然是集中式三层架构的模式，“微服务”内的代码高度耦合，逻辑边界不清晰，这里我们暂且称它为“小单体微服务”**

![small-single](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/small-single.png)

随着新需求的提出和业务的发展，这些小单体微服务会慢慢膨胀起来。当有一天你发现这些膨胀了的微服务，有一部分业务功能需要拆分出去，或者部分功能需要与其它微服务进行重组时，你会发现原来这些看似清晰的微服务，不知不觉已经摇身一变，变成了臃肿油腻的大单体了，而这个大单体内的代码依然是高度耦合且边界不清的。

这种单体式微服务只定义了一个维度的边界，也就是微服务之间的物理边界，本质上还是单体架构模式。微服务设计时要考虑的不仅仅只有这一个边界，还需要定义好微服务内的逻辑边界和代码边界，这样才能得到你想要的结果

### **DDD设计过程梳理出的三个边界**

- **逻辑边界**：**微服务内聚合之间的边界是逻辑边界**。它是一个虚拟的边界，强调业务的内聚，可根据需要变成物理边界，也就是说聚合也可以独立为微服务；
- **物理边界**：**微服务之间的边界是物理边界**。它强调微服务部署和运行的隔离，关注微服务的服务调用、容错和运行等；
- **代码边界**：**不同层或者聚合之间代码目录的边界是代码边界**。它强调的是代码之间的隔离，方便架构演进时代码的重组；

通过以上边界，我们可以让业务能力高内聚、代码松耦合，且清晰的边界，可以快速实现微服务代码的拆分和组合，轻松实现微服务架构演进。随着需求或设计变化，领域模型会迭代，微服务的代码也会分分合合，边界清晰的微服务，可快速实现微服务代码的重组

如果在微服务设计之初按照 DDD 的战略设计方法，定义好了微服务内的逻辑边界，做好了架构的分层，其实我们不必拆分太多的微服务，即使是单体也未尝不可。随着技术积累和能力提升，当我们有了这些能力后，由于应用内有清晰的逻辑边界，我们可以随时轻松地重组出新的微服务，而这个过程不会花费太多的时间和精力

### **DDD严格分层架构下的服务封装与调用**

![DDD严格分层架构下的服务封装与调用](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/DDD%E4%B8%A5%E6%A0%BC%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%B0%81%E8%A3%85%E4%B8%8E%E8%B0%83%E7%94%A8.png)

### **DDD中的数据对象**

1. **数据持久化对象 PO(Persistent Object)**：与数据库结构一一映射，是数据持久化过程中的数据载体；
2. **领域对象 DO（Domain Object）**：微服务运行时的实体，是核心业务的载体；
3. **数据传输对象 DTO（Data Transfer Object）**：用于前端与应用层或者微服务之间的数据组装和传输，是应用之间数据传输的载体；
4. **视图对象 VO（View Object）**：用于封装展示层指定页面或组件的数据；

### **微服务各层数据对象的职责和转换过程**

![微服务各层数据对象的职责和转换过程](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/DDD%E4%B8%A5%E6%A0%BC%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%B0%81%E8%A3%85%E4%B8%8E%E8%B0%83%E7%94%A8.png)

- **基础层**

   基础层的主要对象是 PO 对象。我们需要先建立 DO 和 PO 的映射关系。当 DO 数据需要持久化时，仓储服务会将 DO 转换为 PO 对象，完成数据库持久化操作。当 DO 数据需要初始化时，仓储服务从数据库获取数据形成 PO 对象，并将 PO 转换为 DO，完成数据初始化。大多数情况下 PO 和 DO 是一一对应的。但也有 DO 和 PO 多对多的情况，在 DO 和 PO 数据转换时，需要进行数据重组。

- **领域层**

   领域层的主要对象是 DO 对象。DO 是实体和值对象的数据和业务行为载体，承载着基础的核心业务逻辑。通过 DO 和 PO 转换，我们可以完成数据持久化和初始化。

- **应用层**

   应用层的主要对象是 DO 对象。如果需要调用其它微服务的应用服务，DO 会转换为 DTO，完成跨微服务的数据组装和传输。用户接口层先完成 DTO 到 DO 的转换，然后应用服务接收 DO 进行业务处理。如果 DTO 与 DO 是一对多的关系，这时就需要进行 DO 数据重组。

- **用户接口层**

   用户接口层会完成 DO 和 DTO 的互转，完成微服务与前端应用数据交互及转换。Facade 服务会对多个 DO 对象进行组装，转换为 DTO 对象，向前端应用完成数据转换和传输。

- **前端应用**

   前端应用主要是 VO 对象。展现层使用 VO 进行界面展示，通过用户接口层与应用层采用 DTO 对象进行数据交互。

### **微服务拆分考虑的因素**

理论上一个限界上下文内的领域模型可以被设计为微服务，但是由于**领域建模主要从业务视角出发，没有考虑非业务因素**，比如需求变更频率、高性能、安全、团队以及技术异构等因素，而这些非业务因素对于领域模型的系统落地也会起到决定性作用：

1. **基于业务需求变化频率**：考虑业务变更频率与相关度，将业务需求变动较高和功能相对稳定的业务进行分离。这是因为需求的经常性变动必然会导致代码的频繁修改和版本发布，这种分离可以有效降低频繁变动的敏态业务对稳态业务的影响；
2. **基于应用性能**：因为性能要求高的功能可能会拖累其它功能，在资源要求上也会有区别，为了避免对整体性能和资源的影响，我们可以把在性能方面有较高要求的功能拆分出去；
3. **基于安全边界**：有特殊安全要求的功能，应从领域模型中拆分独立，避免相互影响；
4. **基于技术异构等因素**：领域模型中有些功能虽然在同一个业务域内，但在技术实现时可能会存在较大的差异，也就是说领域模型内部不同的功能存在技术异构的问题。由于业务场景或者技术条件的限制，有的可能用.NET，有的则是 Java，有的甚至大数据架构。对于这些存在技术异构的功能，可以考虑按照技术边界进行拆分；

### **CQRS（Command Query Responsibility Segregation，命令查询责任分离）**

CQRS 模式下，接口分为且只分为两种：

1. 命令（Command），它不返回任何结果，但会改变数据的状态；
2. 查询（Query），它返回结果，但是不会改变数据的状态；

好处：

1. 符合单一职责原则，读写职责分离到不同接口后，方便结合数据库主从架构做读写分离；

2. 读写解耦后，可以对读写逻辑进行物理隔离，这样**读和写就可以单独地进行伸缩、性能调优甚至使用不同技术栈实现**等（不同业务可能读多写少或者写多读少）；

### **思考总结**

如果把软件按照相对的“稳定性”来排序，**领域层＞应用层＞界面层**。以营销为例，撬动用户的还是老三样：卡、券、积分，本质就是营销资产 + 资金流，而从产品包装上可以策划满减、满返、2件折扣、限时优惠、限定电商全场消费、限定活动线下商超、限定品类等活动，不一而足。领域层是相对稳定的，应用层（业务逻辑层和具体规则）可以有多种变化，而广义界面层的实质包括产品包装、交互等可以有更多的互动玩法。因此，**领域分析的价值所在就是寻求“千变万化”中相对的“稳定性、第一性”，然后通过合理的架构分层及抽象隔离的业务复杂度和技术复杂度，隔离业务领域的稳定性和易变性**，从架构上精巧、快速地支持业务的变化。技术为业务服务，但绝不是业务到 IT 的简单翻译；
