## **前言**

本篇文章的起因，源于某次和一位从Google归国的国内创业公司的CTO的聊天，其中聊到的一个话题是：如何才能设计一个可持续维护升级的系统？笔者曾经也在国内BAT之一的公司工作过多年，并在多年的职业生涯中认识和接触了很多国内一线大厂的技术朋友。通过自己多年在国内一线互联网公司的工作经历，以及和国内外明星高科技公司同伴的沟通交流，深刻感觉到这些所谓的一线大厂，对他们的开发人员所交付的系统的期望和要求是什么样的。所以，今天这篇文章，就是和大家聊聊这个话题。

## **由一个问题引发的思考**

如何才能设计一个可持续维护升级的系统？从这位Google背景的CTO提的这个问题，我们可以管中窥豹一下，一线大厂对于开发人员提交的代码或者架构师设计出来的系统架构的真正关注点在哪里。

是语法写的极具trick或用到某个很厉害的语法糖成功炫技？
是代码成功利用了运行平台的某个特性显得极具代码功力？
亦或是架构设计使用了当下流行的架构风格让人一看就觉得不明觉厉？

上面这几个方面对于写代码的人自身来说或许重要，但如果站在公司的角度，或者站在那位CTO提出的问题的角度来看，肯定不是最重要的那几项。因为上面那几点，并没有站在可持续发展的角度来考虑问题。作为公司来说，当其从一个小公司发展成一个大公司，从一条业务线不断孵化出更多元化的业务线，从几个人的小团队发展成上万人的大团队，并希望既有的系统仍然能够持续不断地维护升级以满足需求，那么其核心关注点一定不是上面那几个方面。

简单来说，对公司发展来说真正难的是，随着业务越来越复杂和多元化，随着团队规模不断增长，随着业务发展的越来越复杂，如何能长期多快好省地在既有系统上持续维护升级？

首先澄清一下，持续地在既有系统上进行维护升级，不等同于整个公司就一套系统，这个问题的前提是，按照公司整体业务架构，我们一定得有与之对应的合理的系统边界和不同的系统。在这个前提背景下，这个问题关注的是，对于这个整体架构下的每个单独的系统，我们更希望它是能够长期持续维护升级的。与之相对的是，我们开发出来的很多系统随着业务的发展，很快腐化和不堪重负，不得不推倒重建。

系统的推动重建是一件成本和风险极高的事情，从ROI的角度来说，新建的系统首先必须达到所预期的新回报（比如性能、稳定性、新功能开发效率等），同时还得兼容既有系统的功能和数据，因此比从0到1新开发一个系统的成本都要高（因为没负担）。而且业界现在还有一个怪现象，某些架构师或高工动不动就觉得某个系统架构有问题，希望推动重建，也有不少这样的系统被推动重建了一遍甚至多遍，但最终是否带来了实质性的提升却很难说，但因此而晋升的架构师或高工却不少。

所以，因为种种原因，不到万不得已的时候，公司管理层其实都不愿意推倒重建。所以，如何能够在既有系统的基础上长期持续地维护升级，就变得极其重要。

## **问题拆解**

既然这样，那我们来拆解一下这个问题：如何才能设计一个可持续维护升级的系统？

要回答这个问题，我们就需要思考，一个系统要可持续维护升级，它的维护升级成本主要在哪里，如何才能让这些成本越低越好，而且这个成本并不随着时间的增长而显著增长。

我们知道，一个系统从开发到上线维护再到下线的整个生命周期里，大部分的时间主要花在写代码、读代码和改代码等事情上，而且系统第一版上线后的读代码和改代码的时间会远远大于第一版写代码的时间，尤其在需要持续长时间维护的情况下。

因此，我觉得如果要设计一个可长时间持续维护升级的系统，关键是做好如下三点：

- 好读
- 好改
- 好放心

我们接下来就逐一道来。

### **好读**

所谓好读，是指提升代码以及所有相关交付物的可读性。注意，这里不仅仅包括你写的代码，还包括所有开发过程中产生的交付物，什么是交付物？我认为包括但不限于如下这些：

- 设计文档
- 代码注释
- 代码提交注释
- Code Review Comments
- 配置文件
- 初始化脚本
- readme文档
- changelog文档
- 打印的日志

上面列的不一定全，但核心思路是，只要后续有可能被人类（你自己，当然更有可能是别人）阅读的东西，都应该是【好读】的。

那如何提升可读性，其实就是建立标准和规范，比如代码规范（代码目录结构、变量和方法命名、代码注释等）、开发规范（开发分支规范、代码提交规范、Code Review规范、各种文档规范等），尤其是代码可能很难反映出系统架构全貌，所以必要的整体架构文档（逻辑架构、物理架构）、交互流程文档（时序图）就比较重要了。

因为事实上，代码被阅读的时间会远长于写代码的时间，比如debug的时候、code review的时候、排查线上问题的时候、接手别人代码的时候等等。

著名的开源消息中间件产品RocketMQ中,有一段在网上引起争议和讨论比较大的代码：

![thread0-code](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/thread0-code.png)

红框中的这段代码，核心逻辑其实就只是这一行代码：Thread.sleep(0)，而这段代码给出的唯一注释就是一句话：prevent gc，翻译成白话就是：防止GC线程进行垃圾回收。

如果你读到这段代码和这个注释，你会不会很懵逼，这样就能实现prevent gc了？仅仅通过这段代码和这句似有似无的注释，我们是无从揣测当初写下这段代码的作者的意图的，试想后续如果你需要升级和优化这段代码，是不是会感觉无从下手。

但其实这段代码，通过调用Thread.sleep(0)的目的是为了让GC线程有机会被操作系统选中，从而进行垃圾清理的工作。它的副作用是，可能会更频繁地运行GC，毕竟每1000次迭代就有一次运行GC的机会，但是好处是可以防止长时间的垃圾收集。换句话说，这个代码是想要“触发”GC，而不是“避免”GC，或者说是“避免”时间很长的GC。从这个角度来说，程序里面的注释其实是在错误的或者没写完整。不是prevent gc，而是对GC采取了“打散运行，削峰填谷”的思想，从而prevent long time gc。

而这背后的实现原理，涉及到对Java GC的Safe Point的理解，简而言之就是：用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。一个线程在运行native方法，返回到Java线程后，必须进行一次safepoint的检测，而sleep方法正好就是一个native方法。

看到这里是不是感觉自己对Java GC的理解还是太肤浅了，还需要回去好好补补课？但同时是否也会感慨，没有多年的功力应该写不出这么厉害的代码？

但是回到我们讨论的话题，这是一段好读的代码吗？写代码的大牛屠龙技是耍开心了，但维护升级的小兄弟们一脸懵逼了。其实但凡这位前辈大牛用点心写注释，把这样写的背景和原理介绍清楚，让后人能够读懂其意图后，这段代码还是可以优化的，比如其中一个优化方案就是：把循环变量i的类型从int修改为long，这样就能删除掉那段看起来莫名其妙的代码了。

### **好改**

所谓好改，则依赖于建立合理清晰可扩展的代码结构和系统架构，这也就要求代码结构和系统架构具备良好的风格和设计模式，比如

- 面向对象设计的solid原则（单一职责原则、开闭原则、里氏克夫替换原则、接口隔离原则、依赖倒置原则）；
- 分层依赖原则，典型如分层模式mvc、基于事件的异步架构模式CQRS等，让架构分层、模块划分更清晰合理；

比如，DDD领域驱动设计中推荐的代码结构，分为如下四层：

![DDD-4-level-arch](https://github.com/xiaoyuge/Tech-Notes/raw/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/DDD-4-level-arch.png)

即用户接口层、应用层、领域层和基础层。

而且这四层代码需要遵循严格分层架构，也即每层只能与位于其下方的层发生耦合，在严格分层架构模式下，不允许服务的跨层调用，每个服务只能调用它的下一层服务。服务从下到上依次为：实体方法、领域服务和应用服务。在严格分层架构中，服务如果需要跨层调用，下层服务需要在上层封装后，才可以提供跨层服务。比如实体方法需要向应用服务提供服务，它需要封装成领域服务。

严格分层架构使得程序结构变得清晰，升级和维护更加容易。我们修改某层代码时，只要本层的接口参数不变，其它层可以不必修改。即使本层的接口发生变化，也只影响相邻的上层，修改工作量小且错误可以控制，不会带来意外的风险。如果需要实现服务的跨层调用，建议采用服务逐层封装的方式，如下所示：

![servie-pakage-by-level](https://github.com/xiaoyuge/Tech-Notes/raw/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/servie-pakage-by-level.png)

DDD四层分层架构的优势就是隔离变化或者说关注点分离，其通过前端或后端适配，逐层控制外部变化向领域层传导，从而降低外部变化对领域层的影响（领域层应该跟随领域模型变化，而不是跟随前端应用而变化），也即，逐层隔离变化，比如：

- 在前端应用中可以消化掉页面逻辑和页面流程类需求；
- 在用户接口层可以完成前端应用接口和数据适配，避免将接口和数据适配类需求传导到应用层；
- 在应用层通过服务组合和编排，可以避免用例或服务组合类需求向领域层传导；
- 在基础设施层通过依赖倒置设计，可以隔离技术组件变化对领域逻辑的影响；

其实道理说了这么多，归结起来就是两个字：好改。

### **好放心**

所谓好放心，则是指构建完备的自动化测试网。好的代码结构和架构设计，能够让我们以更低的成本修改，而且相对来说也比较不容易引入Bug，但是为了更大程度的保障每次修改的安全，一张完备的自动化测试网络还是必不可少的。

业界有一个所谓的测试三角形模型，描述了不同层级的自动化测试，如下图：

![auto-test-level](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/resources/auto-test-level.png)

这个模型描述了从单元测试、集成测试到 UI 测试的渐进式测试过程。越是靠近底层，用例的执行速度就越快，维护成本也越低。而在最上层的 UI 层，执行速度要比单元测试和接口测试要慢，比手工测试要快，相应的维护成本要远高于单元测试和接口测试。

从成本和收益的角度考虑，对于基于web的应用，可以考虑以API接口测试为主，以单元测试和 UI 测试为辅：

- 单元测试：单元测试更多是由开发主导的，开发领导的态度就决定了运行的效果。但不可否认的是，单元测试还是非常必要的，尤其是针对核心服务，比如核心交易模块的覆盖率。当然，好的单元测试需要研发投入大量的精力；

- API测试：综合考虑投入产出比和上手难度的话，位于中间层的接口测试就成了一种很好的选择。一方面，现代软件架构无论是分层还是服务调用模式，对接口的依赖程度都大大增加。比如典型的前后端分离的开发模式，前后端基本都是在围绕着接口进行开发联调。另一方面，与单元测试相比，接口测试调用的业务逻辑更加完整，并且具备清晰的接口定义，适合采用自动化的方式执行；

- UI测试：UI 层是唯一能够模拟用户真实操作场景的端到端测试，页面上的一个按钮可能触发内部几十个函数调用，和单元测试每次只检查一个函数的逻辑不同，UI 测试更加关注模块集成后的联动逻辑，是集成测试最有效的手段。但缺点也是比较明显的：随着敏捷迭代的速度越来越快，UI 控件的频繁变更会导致控件定位不稳定，提高了用例脚本的维护成本；