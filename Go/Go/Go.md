## **GO的特点**
### **开发体验**：
简单的语法（尽量少的语言特性）、得心应手的工具链、丰富和健壮的标准库、免除内存管理的心智负担，对并发设计的原生支持等等

### **解释or编译**：
静态编译语言

### **开发效率**：
高

### **运行效率（性能）**：
在相同的资源消耗水平的前提下，Go 的性能虽然低于 C++，但高出 Java 不少，比 Python 代码大约快30-40倍

### **应用场景**：
Go 创建的最初目的，就是构建流行的、**高性能的服务器端编程语言**，用以替代当时在这个领域使用较多的 Java 和 C++。在云原生基础设施、中间件与云服务领域大放异彩

### **典型产品**：
现代云计算基础设施软件的大部分流行和可靠的作品，都是用 Go 编写的，比如：Docker、Kubernetes、Prometheus、Ethereum（以太坊）、Istio、CockroachDB、InfluxDB、Terraform、Etcd、Consul 等等

### **垃圾回收**：
Go是带GC的编程语言，早期GO的GC 延迟比较大，成为了 Go 语言上生产环境的最大障碍。Go 1.5 版本对 GC 延迟进行了大幅优化 。Go的GC虽然在go团队的努力下，开销越来越小，但开销小，低延迟不代表没有，这就决定了**Go在一些对性能极其敏感的领域可能并不是最好的选择**

### **社区活跃度和生态成熟度**：
java诞生年头多，且是目前企业应用领域的第一语言，其社区自然更好一些。生态成熟度也是如此，现在很难找到一个领域没有java的开源实现。实话说，go在这方面规模还不及java，但是增长速度要更快

### **面向并发而生**

![gartner-go](https://github.com/xiaoyuge/Tech-Notes/blob/main/Go/Go/resources/Gartner-Go.png)


从 Go 本身的发展来看，和多数编程语言一样，Go 语言在诞生后，度过了一个较长的“技术萌芽期”。然后，实现了自举，而且对 GC 延迟进行了大幅优化的 Go 1.5 版本，成为了 Go 语言演化过程中的第一个“引爆点”，推动 Go 语言进入“技术膨胀期”，也正是在这段时间内，Go 语言以迅雷不及掩耳盗铃之势推出了以 **Docker、Kubernetes 为典型代表的“杀手级应用”**

从 TIOBE 提供的曲线来看，Go 1.12 到 Go 1.15 版本的发布让我们有信心认为 Go 已经走出“泡沫破裂谷底期”，进入到“稳步爬升的光明期”。预计在 2022 年初发布的支持 Go 泛型特性的 Go 1.18 版本，会是继 Go 1.5 版本之后又一“爆款”，很可能会快速推动 Go 迈入更高的发展阶段。绝大多数主流编程语言，都将在其 15 至 20 年间大步前进。Java、Python、Ruby、JavaScript 和许多其他编程语言都是这样。如今 Go 语言也马上进入自己的黄金 5～10 年，从前面的技术成熟度曲线分析也可以印证这一点：Go 已经重新回到“稳步爬升的光明期”

### **自举**
和很多主流语言一样，**Go语言编译器最初都是由C语言和汇编语言实现的**。

C语言和汇编实现的Go编译器(记作A)用来编译Go源文件。那么问题来了？是否可以用Go语言自身实现一个Go编译器B，用编译器A来编译Go编译器B工程的源码并链接成最终的Go编译器B呢？

这就是Go核心团队在Go 1.5版本时做的事情。他们将绝大多数原来用C和汇编编写的Go编译器以及运行时实现改为使用Go语言编写，并用Go 1.4.x编译器(C与汇编实现的，相当于A)编译出Go 1.5编译器。这样自Go 1.5版本开始，Go编译器就是用Go语言实现的了，这就是**所谓的自举：即用要编译的目标编程语言(Go语言)编写其（Go）编译器**

这之后，**Go核心团队基本就告别C代码了，可以专心写Go代码了**。这可以让Go核心团队积累更为丰富的Go语言编码经验，也算是一种“吃狗粮”。同时Go语言自身就是站在C语言等的肩膀上，修正了C语言等的缺陷并加入创新机制而形成的，**用Go编码效率高，还可避面C语言的很多坑。 在这个基础上，使用Go语言实现编译器和runtime还利于Go编译器以及运行时的优化**，Go 1.5及后续版本GC延迟大幅降低以及性能的大幅提升都说明了这一点。这就是自举的重要之处

### **Go VS Python**
在机器学习领域，python是当之无愧的老大。但python也有自己的瓶颈，主要是性能相较于静态语言有数量级差距，各个编程语言也都试图争抢python在机器学习领域的份额，包括julia、c++、rust，Go也不例外。但与在云原生领域的投入相比，Go社区在机器学习算法库方向上的投入还不够，但也有一些成果，比较知名的项目包括gonum、gorgonia等。在帮助构建机器学习/深度学习平台层面上，go倒是发挥了更大的作用，比如kubeflow，机器学习算法上，python已经形成一家独大之势

### **Go VS Java**
从语言语法、生产力、性能、社区活跃度，生态成熟度、发展前景等几个方面看
- **语言语法**：java是不折不扣的面向对象编程语言，就像“java编程思想”一书中说：“一切都是对象”。而go是传统的**命令式编程语言**，按照go语言family图谱，它的先祖来自C、Pascal、Newsqueak等。语法简单，但谈不上“领先”。另外，java的语法特性（所谓的语法糖）越来越复杂，而go相对保持着语法简洁；

- **生产力**：目前来看go是要高于java，同样是以为语法简洁

- **性能**：同资源消耗下，go也是要高于java的。另外一点就是即便是新手写go，性能也不会很差

- **社区活跃度和生态成熟度**：两者都是主流语言，java诞生年头多，且是目前企业应用领域的第一语言，其社区自然更好一些。生态成熟度也是如此，现在很难找到一个领域没有java的开源实现。实话说，go在这方面规模还不及java，但是增长速度要更快

### **额外知识——编译器**
一个编译器的完整编译过程包括：词法分析，语法分析，类型检查，中间代码生成，代码优化，目标代码生成，目标代码优化等几个阶段。从词法分析到中间代码生成，这就是编译器前端所要负责的事情。而代码优化和目标代码生成，则是编译器后端的职责

### **Go运行时**
也称为go runtime，其本身就是每个go程序的一部分，它会跟你的源码一起编译并连接到目标程序中（静态编译）。即便你只是写了一个hello world程序，这个程序中也包含了runtime的实现。 
- 它在我的程序中具体负责什么？runtime负责实现go的垃圾收集、并发、内存堆栈管理以及Go语言的其他关键功能。 
- 它的代码在哪里？它大部分以标准库的形式存放在每个Go发布版的源码中

### **GO的设计哲学**
1. **简单**

    Go 语言的设计者们在语言设计之初，就拒绝了走语言特性融合的道路，选择了“做减法”并致力于打造一门简单的编程语言

    在 Go 语言中看不到传统的面向对象的类、构造函数与继承，看不到结构化的异常处理，也**看不到本属于函数编程范式的语法元素**，Go 设计者选择的“简单”，是站在巨人肩膀上，去除或优化了以往语言中，已经被开发者证明为体验不好或难以驾驭的语法元素和语言机制，并提出了自己的一些创新性的设计。比如，首字母大小写决定可见性、变量初始为类型零值、内置以 go 关键字实现的并发支持等。

    简单所带来的收益：简单意味着可以使用更少的代码实现相同的功能，简单意味着代码具有更好的可读性，而可读性好的代码通常意味着更好的可维护性以及可靠性。

2. **显示**

    Go 与 C 语言的隐式自动类型转换不同，Go 不允许不同类型的整型变量进行混合计算，它同样也不会对其进行隐式的自动转换

    在 Go 语言中，不同类型变量是不能在一起进行混合计算的，这是因为 Go 希望开发人员明确知道自己在做什么，这与 C 语言的“信任程序员”原则完全不同，因此你需要以显式的方式通过转型统一参与计算各个变量的类型

    Go 设计者所崇尚的显式哲学还直接决定了 Go 语言错误处理的形态：Go 语言采用了显式的基于值比较的错误处理方案，函数 / 方法中的错误都会通过 return 语句显式地返回，并且通常调用者不能忽略对返回的错误的处理

3. **组合**

    Go 语言不像 C++、Java 等主流面向对象语言，我们在 Go 中是找不到经典的面向对象语法元素、类型体系和继承机制的，Go 推崇的是组合的设计哲学

    无论是包、接口还是一个个具体的类型定义，Go 语言其实是为我们呈现了这样的一幅图景：一座座没有关联的“孤岛”，但每个岛内又都很精彩。那么现在摆在面前的工作，就是在这些孤岛之间以最适当的方式建立关联，并形成一个整体。而 Go 选择采用的组合方式，也是最主要的方式

    Go 语言为支撑组合的设计提供了类型嵌入（Type Embedding）。通过类型嵌入，我们可以将已经实现的功能嵌入到新类型中，以快速满足新类型的功能需求，这种方式有些类似经典面向对象语言中的“继承”机制，但在原理上却与面向对象中的继承完全不同，这是一种 Go 设计者们精心设计的“语法糖”

    被嵌入的类型和新类型两者之间没有任何关系，甚至相互完全不知道对方的存在，更没有经典面向对象语言中的那种父类、子类的关系，以及向上、向下转型（Type Casting）。通过新类型实例调用方法时，方法的匹配主要取决于方法名字，而不是类型。这种组合方式，我称之为**垂直组合**，即通过类型嵌入，快速让一个新类型“复用”其他类型已经实现的能力，实现功能的垂直扩展。垂直组合本质上是一种“能力继承”，采用嵌入方式定义的新类型继承了嵌入类型的能力

    Go 还有一种常见的组合方式，叫**水平组合**。和垂直组合的能力继承不同，水平组合是一种**能力委托（Delegate）**，我们通常使用接口类型来实现水平组合

    组合原则的应用实质上是塑造了 Go 程序的骨架结构。类型嵌入为类型提供了垂直扩展能力，而接口是水平组合的关键，它好比程序肌体上的“关节”，给予连接“关节”的两个部分各自“自由活动”的能力，而整体上又实现了某种功能

4. **并发**

     Go 没有采用基于线程的并发模型，Go 放弃了传统的基于操作系统线程的并发模型，而采用了用户层轻量级线程，Go 将之称为 goroutine

    goroutine 占用的资源非常小，Go 运行时默认为每个 goroutine 分配的栈空间仅 2KB。goroutine 调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。因此，一个 Go 程序中可以创建成千上万个并发的 goroutine。而且，所有的 Go 代码都在 goroutine 中执行，哪怕是 go 运行时的代码也不例外

    在提供了开销较低的 goroutine 的同时，Go 还在语言层面内置了辅助并发设计的原语：channel 和 select。开发者可以通过语言内置的 channel 传递消息或实现同步，并通过 select 实现多路 channel 的并发控制。相较于传统复杂的线程并发模型，Go 对并发的原生支持将大大降低开发人员在开发并发程序时的心智负担

    采用并发方案设计的程序在单核处理器上也是可以正常运行的，也许在单核上的处理性能可能不如非并发方案。但随着处理器核数的增多，并发方案可以自然地提高处理性能

### **Go 调度器实现机制：G-P-M模型**
Go 程序通过调度器来调度 Goroutine 在内核线程上执行，但是 Goroutine 并不直接绑定 OS 线程 M 运行，而是由 Goroutine Scheduler 中的  P 来作获取内核线程资源的“中介”。

Go 调度器模型通常被称为 G-P-M 模型，它包括 4 个重要结构，分别是 G、P、M、Sched：
* G（Goroutine）：每个 Goroutine 对应一个 G 结构体，G 存储 Goroutine 的运行堆栈、状态以及任务函数，可重用。G 并非执行体，每个 G 需要绑定到 P 才能被调度执行；
* P（Processor）：表示逻辑处理器。P 的数量决定了系统内最大可并行的 G 的数量，前提是物理 CPU 核数≥P 的数量；
* M（Machine）： OS 内核线程抽象，代表真正执行计算的资源，在绑定有效的 P 后，进入 schedule 循环。而 schedule 循环的机制大致是从 Global 队列、P 的本地队列以及 wait 队列中获取。M 的数量是不定的，由 Go Runtime 调整，M 并不保留 G 状态，这是 G 可以跨 M 调度的基础；
* Sched： Go 调度器。它维护存储 M 和 G 的队列以及调度器的一些状态信息。调度器循环的机制大致是从各种队列、P 的本地队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 Goexit 做清理工作并回到 M，如此反复；

![gpm-model](https://github.com/xiaoyuge/Tech-Notes/blob/main/Go/Go/resources/GPM-Model.jpg)

P 代表可以“并行”运行的逻辑处理器，每个 P 都被分配到一个系统线程 M，G 代表 Go 协程。

Go 调度器中有两个不同的运行队列：全局运行队列 (GRQ) 和本地运行队列 (LRQ)。每个 P 都有一个 LRQ，用于管理分配在 P 的上下文中执行的 Goroutines，这些 Goroutine 轮流被与 P 绑定的 M 进行上下文切换。GRQ 适用于尚未分配给 P 的 Goroutines。

G 的数量可以远远大于 M 的数量，换句话说，Go 程序可以利用少量的内核级线程来支撑大量 Goroutine 的并发。多个 Goroutine 通过用户级别的上下文切换来共享内核线程 M 的计算资源，但对于操作系统来说并没有线程上下文切换产生的性能损耗。

为了更加充分地利用线程的计算资源，Go 调度器采取了以下几种调度策略：
1. 任务窃取（work-stealing）
有的 Goroutine 运行快，有 Goroutine 运行慢。当每个 P 之间的 G 任务不均衡时，调度器允许从 GRQ，或者其他 P 的 LRQ 中获取 G 执行。

2. 减少阻塞
如果正在执行的 Goroutine 阻塞了线程 M 怎么办？P 上 LRQ 中的 Goroutine 会获取不到调度吗？

在 Go 中，阻塞主要分为以下 4 种场景。
* 场景 1：由于原子、互斥量或通道操作调用导致  Goroutine  阻塞。调度器将把当前阻塞的 Goroutine 切换出去，重新调度 LRQ 上的其他 Goroutine；
* 场景 2：由于网络请求和 IO 操作导致  Goroutine  阻塞。此时，Go 程序会提供网络轮询器（NetPoller）来处理网络请求和 IO 操作的问题，其后台通过 kqueue（MacOS），epoll（Linux）或  iocp（Windows）来实现 IO 多路复用。通过使用网络轮询器进行网络系统调用，调度器可以防止  Goroutine  在进行这些系统调用时阻塞 M。这可以让 M 执行 P 的  LRQ  中其他的  Goroutines，而不需要创建新的 M。有助于减少操作系统上的调度负载；
* 场景 3：在调用一些系统方法的过程中发生阻塞。这种情况下，网络轮询器无法使用，而进行系统调用的  Goroutine  将阻塞当前 M。此时，调度器将阻塞的 M 与 P 分离，同时创建新 M 来服务 P；
* 场景 4：如果在 Goroutine 中执行一个 sleep 操作，导致 M 被阻塞了。 Go 程序后台有一个监控线程 sysmon，它监控那些长时间运行的 G 任务然后设置可以抢占的标识符，别的 Goroutine 就可以抢先进来执行。只要下次这个 Goroutine 进行函数调用，那么就会被强占，同时也会保护现场，然后重新放入 P 的本地队列里面等待下次执行。


5. **面向工程**

Go 在标准库中提供了各类高质量且性能优良的功能包，其中的net/http、crypto、encoding等包充分迎合了云原生时代的关于 API/RPC Web 服务的构建需求，Go 开发者可以直接基于标准库提供的这些包实现一个满足生产要求的 API 服务，从而**减少对外部第三方包或库的依赖，降低工程代码依赖管理的复杂性，也降低了开发人员学习第三方库的心理负担**

在工程过程中肯定是需要使用工具的，Go 语言就提供了足以让所有其它主流语言开发人员羡慕的工具链，**工具链涵盖了编译构建、代码格式化、包依赖管理、静态代码检查、测试、文档生成与查看、性能剖析、语言服务器、运行时程序跟踪**等方方面面。在提供丰富的工具链的同时，Go 在标准库中提供了官方的词法分析器、语法解析器和类型检查器相关包，开发者可以基于这些包快速构建并扩展 Go 工具链

总结一下Go的设计哲学：
* 简单是指 Go 语言特性始终保持在少且足够的水平，不走语言特性融合的道路，但又不乏生产力。简单是 Go 生产力的源泉，也是 Go 对开发者的最大吸引力；
* 显式是指任何代码行为都需开发者明确知晓，不存在因“暗箱操作”而导致可维护性降低和不安全的结果；
* 组合是构建 Go 程序骨架的主要方式，它可以大幅降低程序元素间的耦合，提高程序的可扩展性和灵活性；
* 并发是 Go 敏锐地把握了 CPU 向多核方向发展这一趋势的结果，可以让开发人员在多核时代更容易写出充分利用系统资源、支持性能随 CPU 核数增加而自然提升的应用程序；
* 面向工程是 Go 语言在语言设计上的一个重大创新，它将语言要解决的问题域扩展到那些原本并不是由编程语言去解决的领域，从而覆盖了更多开发者在开发过程遇到的“痛点”，为开发者提供了更好的使用体验；


### **Go的包依赖管理机制**

Go module 已经成为了 Go 默认的包依赖管理机制和 Go 源码构建机制

Go Module 的核心是一个名为 go.mod 的文件，在这个文件中存储了这个 module 对第三方依赖的全部信息

一个 module 就是一个包的集合，这些包和 module 一起打版本、发布和分发。**go.mod 所在的目录被我们称为它声明的 module 的根目录**

module 隐含了一个命名空间的概念，module 下每个包的导入路径都是由 module path 和包所在子目录的名字结合在一起构成

**Go 包是 Go 语言的基本组成单元**。一个 Go 程序就是一组包的集合，所有 Go 代码都位于包中；

Go 源码可以导入其他 Go 包，并使用其中的导出语法元素，包括类型、变量、函数、方法等，而且，main 函数是整个 Go 应用的入口函数；

Go 源码需要先编译，再分发和运行。如果是单 Go 源文件的情况，我们可以直接使用 go build 命令 + Go 源文件名的方式编译。不过，对于复杂的 Go 项目，我们需要在 Go Module 的帮助下完成项目的构建


### **一个Go项目的代码结构布局**

（1）可执行程序项目 \
```
├── cmd/ 
│   ├── app1/ 
│   │   └── main.go 
│   └── app2/ 
│       └── main.go 
├── go.mod 
├── go.sum 
├── internal/ 
│   ├── pkga/ 
│   │   └── pkg_a.go 
│   └── pkgb/ \
│       └── pkg_b.go 
├── pkg1/ 
│   └── pkg1.go 
├── pkg2/ 
│   └── pkg2.go 
└── vendor/ 
```

1. cmd目录

    **cmd目录就是存放项目要编译构建的可执行文件对应的 main 包的源文件**。如果你的项目中有多个可执行文件需要构建，每个可执行文件的 main 包单独放在一个子目录中，比如图中的 app1、app2，cmd 目录下的各 app 的 main 包将整个项目的依赖连接在一起。通常来说，main 包应该很简洁。我们在 main 包中会做一些命令行参数解析、资源初始化、日志设施初始化、数据库连接初始化等工作，之后就会将程序的执行权限交给更高级的执行控制对象；

2. pkgN 目录：

    存放项目自身要使用、同样也是可执行文件对应 main 包所要依赖的库文件，同时这些目录下的包还可以被外部项目引用；
3. go.mod 和 go.sum：

    它们是 Go 语言包依赖管理使用的配置文件；
4. vendor 目录：

    vendor 是 Go 1.5 版本引入的用于在项目本地缓存特定版本依赖包的机制，在 Go Modules 机制引入前，基于 vendor 可以实现可重现构建，保证基于同一源码构建出的可执行程序是等价的。这里将 vendor 目录视为一个可选目录。原因在于，Go Module 本身就支持可再现构建，而无需使用 vendor；

如果 Go 可执行程序项目有一个且只有一个可执行程序要构建，那就比较好办了，我们可以将上面项目布局进行简化：
```
single-exe-layout
├── go.mod
├── internal/
├── main.go
├── pkg1/
├── pkg2/
└── vendor/
```

（2）库项目：Go 库项目仅对外暴露 Go 包，这类项目的典型布局形式是这样的
```
lib-layout
├── go.mod
├── internal/
│   ├── pkga/
│   │   └── pkg_a.go
│   └── pkgb/
│       └── pkg_b.go
├── pkg1/
│   └── pkg1.go
└── pkg2/
    └── pkg2.go
```

1. 库类型项目相比于 Go 可执行程序项目的布局要简单一些。因为这类项目不需要构建可执行程序，所以去除了 cmd 目录；
2. vendor 也不再是可选目录了。对于库类型项目而言，我们并不推荐在项目中放置 vendor 目录去缓存库自身的第三方依赖，库项目仅通过 go.mod 文件明确表述出该项目依赖的 module 或包以及版本要求就可以了；
3. Go 库项目的初衷是为了对外部（开源或组织内部公开）暴露 API，对于仅限项目内部使用而不想暴露到外部的包，可以放在项目顶层的 internal 目录下面；

对于有一个且仅有一个包的 Go 库项目来说，我们也可以将上面的布局做进一步简化，简化的布局如下所示：
```
single-pkg-lib-layout
├── feature1.go
├── feature2.go
├── go.mod
└── internal/
```

### **Go构建模式**
Go 程序由 Go 包组合而成的，Go 程序的构建过程就是确定包版本、编译包以及将编译后得到的目标文件链接在一起的过程

Go 语言的构建模式历经了三个迭代和演化过程，分别是最初期的 GOPATH、1.5 版本的 Vendor 机制，以及现在的 Go Module

1) GOPATH：

    在这种构建模式下，Go 编译器可以在本地 GOPATH 环境变量配置的路径下，搜寻 Go 程序依赖的第三方包。如果存在，就使用这个本地包进行编译；如果不存在，就会报编译错误。如果你没有显式设置 GOPATH 环境变量，Go 会将 GOPATH 设置为默认值，不同操作系统下默认值的路径不同，在 macOS 或 Linux 上，它的默认值是 $HOME/go；

    如果没有找到所需要的包，我们可以通过 go get 命令将本地缺失的第三方依赖包下载到本地， go get 命令，不仅能将 logrus 包下载到 GOPATH 环境变量配置的目录下，它还会检查 logrus 的依赖包在本地是否存在，如果不存在，go get 也会一并将它们下载到本地

    不过，go get 下载的包只是那个时刻各个依赖包的最新主线版本，这样会给后续 Go 程序的构建带来一些问题。比如，依赖包持续演进，可能会导致不同开发者在不同时间获取和编译同一个 Go 包时，得到不同的结果，也就是不能保证可重现的构建（Reproduceable Build）。又比如，如果依赖包引入了不兼容代码，程序将无法通过编译

    在 GOPATH 构建模式下，Go 编译器实质上并没有关注 Go 项目所依赖的第三方包的版本。但 Go 开发者希望自己的 Go 项目所依赖的第三方包版本能受到自己的控制，而不是随意变化。于是 Go 核心开发团队引入了 Vendor 机制试图解决上面的问题

2) Vendor：

    Go 在 1.5 版本中引入 vendor 机制。vendor 机制本质上就是在 Go 项目的某个特定目录下，将项目的所有依赖包缓存起来，这个特定目录名就是 vendor

    Go 编译器会优先感知和使用 vendor 目录下缓存的第三方包版本，而不是 GOPATH 环境变量所配置的路径下的第三方包版本。这样，无论第三方依赖包自己如何变化，无论 GOPATH 环境变量所配置的路径下的第三方包是否存在、版本是什么，都不会影响到 Go 程序的构建

    如果你将 vendor 目录和项目源码一样提交到代码仓库，那么其他开发者下载你的项目后，就可以实现可重现的构建。因此，如果使用 vendor 机制管理第三方依赖包，最佳实践就是将 vendor 一并提交到代码仓库中

    要想开启 vendor 机制，你的 Go 项目必须位于 GOPATH 环境变量配置的某个路径的 src 目录下面。如果不满足这一路径要求，那么 Go 编译器是不会理会 Go 项目目录下的 vendor 目录的

    vendor 机制虽然一定程度解决了 Go 程序可重现构建的问题，但对开发者来说，它的体验却不那么好。一方面，Go 项目必须放在 GOPATH 环境变量配置的路径下，庞大的 vendor 目录需要提交到代码仓库，不仅占用代码仓库空间，减慢仓库下载和更新的速度，而且还会干扰代码评审，对实施代码统计等开发者效能工具也有比较大影响

    另外，你还需要手工管理 vendor 下面的 Go 依赖包，包括项目依赖包的分析、版本的记录、依赖包获取和存放，等等，最让开发者头疼的就是这一点

3) Go module：

    Go 官方的解决方案，一个 Go Module 是一个 Go 包的集合。module 是有版本的，所以 module 下的包也就有了版本属性。这个 module 与这些包会组成一个独立的版本单元，它们一起打版本、发布和分发

    在 Go Module 模式下，通常一个代码仓库对应一个 Go Module。一个 Go Module 的顶层目录下会放置一个 go.mod 文件，每个 go.mod 文件会定义唯一一个 module，也就是说 Go Module 与 go.mod 是一一对应的

    go.mod 文件所在的顶层目录也被称为 module 的根目录，module 根目录以及它子目录下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module

将基于当前项目创建一个 Go Module，通常有如下几个步骤：
- 第一步：通过 go mod init 创建 go.mod 文件，将当前项目变为一个 Go Module；
- 第二步：通过 go mod tidy 命令自动更新当前 module 的依赖信息，go mod tidy 命令会扫描 Go 源码，并自动找出项目依赖的外部 Go Module 以及版本，下载这些依赖并更新本地的 go.mod 文件。Go Module 还支持通过 Go Module 代理服务加速第三方依赖的下载。 代理服务可以铜通过GOPROXY 环境变量修改，这个环境变量的默认值为“https: // proxy.golang.org,direct”，不过我们可以配置更适合于中国大陆地区的 Go Module 代理服务；
- 第三步：执行 go build，执行新 module 的构建，go build 命令会读取 go.mod 中的依赖及版本信息，并在本地 module 缓存路径下找到对应版本的依赖 module，执行编译和链接

### **go.sum的作用**
这是 Go Module 的一个安全措施。当将来这里的某个 module 的特定版本被再次下载的时候，go 命令会使用 go.sum 文件中对应的哈希值，和新下载的内容的哈希值进行比对，只有哈希值比对一致才是合法的，这样可以确保你的项目所依赖的 module 内容，不会被恶意或意外篡改。因此，推荐把 go.mod 和 go.sum 两个文件与源码，一并提交到代码版本控制服务器上

 Go Module 机制会自动分析项目的依赖包，并选出最适合的版本后，不知道你会不会有这样的疑惑：项目所依赖的包有很多版本，Go Module 是如何选出最适合的那个版本的呢？

### **深入 Go Module 构建模式**
Go 语言设计者在设计 Go Module 构建模式，来解决“包依赖管理”的问题时，进行了几项创新，这其中就包括语义导入版本 (Semantic Import Versioning)，以及和其他主流语言不同的最小版本选择 (Minimal Version Selection) 等机制

1) 语义导入版本 (Semantic Import Versioning)

    go.mod 的 require 段中依赖的版本号，都符合 vX.Y.Z 的格式。在 Go Module 构建模式下，一个符合 Go Module 要求的版本号，由前缀 v 和一个满足语义版本规范的版本号组成，语义版本号分成 3 部分：主版本号 (major)、次版本号 (minor) 和补丁版本号 (patch)

    ![go-version](https://github.com/xiaoyuge/Tech-Notes/blob/main/Go/Go/resources/go-version.png)

    按照语义版本规范，主版本号不同的两个版本是相互不兼容的。而且，在主版本号相同的情况下，次版本号大都是向后兼容次版本号小的版本。补丁版本号也不影响兼容性

    Go Module 规定：如果同一个包的新旧版本是兼容的，那么它们的包导入路径应该是相同的

    以 logrus 为例，它有很多发布版本，我们从中选出两个版本 v1.7.0 和 v1.8.1.。按照上面的语义版本规则，这两个版本的主版本号相同，新版本 v1.8.1 是兼容老版本 v1.7.0 的。那么，我们就可以知道，如果一个项目依赖 logrus，无论它使用的是 v1.7.0 版本还是 v1.8.1 版本，它都可以使用下面的包导入语句导入 logrus 包：

    import "github.com/sirupsen/logrus”

    假如在未来的某一天，logrus 的作者发布了 logrus v2.0.0 版本。那么根据语义版本规则，该版本的主版本号为 2，已经与 v1.7.0、v1.8.1 的主版本号不同了，那么 v2.0.0 与 v1.7.0、v1.8.1 就是不兼容的包版本。然后我们再按照 Go Module 的规定，如果一个项目依赖 logrus v2.0.0 版本，那么它的包导入路径就不能再与上面的导入方式相同了。

    Go Module 创新性地给出了一个方法：将包主版本号引入到包导入路径中，我们可以像下面这样导入 logrus v2.0.0 版本依赖包：

    import "github.com/sirupsen/logrus/v2”

    这就是 Go 的“语义导入版本”机制，也就是说通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本，这样一来我们甚至可以同时依赖一个包的两个不兼容版本

    按照语义版本规范的说法，v0.y.z 这样的版本号是用于项目初始开发阶段的版本号。在这个阶段任何事情都有可能发生，其 API 也不应该被认为是稳定的。Go Module 将这样的版本 (v0) 与主版本号 v1 做同等对待，也就是采用不带主版本号的包导入路径，这样一定程度降低了 Go 开发人员使用这样版本号包时的心智负担。

    Go 语义导入版本机制是 Go Module 机制的基础规则，同样它也是 Go Module 其他规则的基础

2) 最小版本选择 (Minimal Version Selection) 

    ![go-minimum-version](https://github.com/xiaoyuge/Tech-Notes/blob/main/Go/Go/resources/go-mininum-version.jpg)

    在这张图中，myproject 有两个直接依赖 A 和 B，A 和 B 有一个共同的依赖包 C，但 A 依赖 C 的 v1.1.0 版本，而 B 依赖的是 C 的 v1.3.0 版本，并且此时 C 包的最新发布版为 C v1.7.0。这个时候，Go 命令是如何为 myproject 选出间接依赖包 C 的版本呢？选出的究竟是 v1.7.0、v1.1.0 还是 v1.3.0 呢？

    当前存在的主流编程语言，以及 Go Module 出现之前的很多 Go 包依赖管理工具都会选择依赖项的“最新最大 (Latest Greatest) 版本”，对应到图中的例子，这个版本就是 v1.7.0

    Go 设计者另辟蹊径，在诸多兼容性版本间，他们不光要考虑最新最大的稳定与安全，还要尊重各个 module 的述求：A 明明说只要求 C v1.1.0，B 明明说只要求 C v1.3.0。所以 Go 会在该项目依赖项的所有版本中，选出符合项目整体要求的“最小版本”

    **这个例子中，C v1.3.0 是符合项目整体要求的版本集合中的版本最小的那个**，于是 Go 命令选择了 C v1.3.0，而不是最新最大的 C v1.7.0。并且，Go 团队认为“最小版本选择”为 Go 程序实现持久的和可重现的构建提供了最佳的方案

    PS最小版本算法解释：A 要求 >=C v1.1.0，B 要求 C >=v1.3.0，那么选择同时满足A与B要求的最小版本，就是v1.3.0。如果选择v1.1.0则不满足A要求

### **Go module的包依赖管理操作**
* 通过 go get 我们可以升级或降级某依赖的版本，如果升级或降级前后的版本不兼容，这里千万注意别忘了变化包导入路径中的版本号，这是 Go 语义导入版本机制的要求；
* 通过 go mod tidy，我们可以自动分析 Go 源码的依赖变更，包括依赖的新增、版本变更以及删除，并更新 go.mod 中的依赖信息；
* 通过 go mod vendor，我们依旧可以支持 vendor 机制，并且可以对 vendor 目录下缓存的依赖包进行自动管

### **Go程序的执行次序**
Go 程序由一系列 Go 包组成，代码的执行也是在各个包之间跳转。和其他语言一样，Go 也拥有自己的用户层入口：main 函数

main 包中的 main 函数，也就是 main.main，它是所有 Go 可执行程序的用户层执行逻辑的入口函数。Go 程序在用户层面的执行逻辑，会在这个函数内按照它的调用顺序展开

Go 语言要求：可执行程序的 main 包必须定义 main 函数，否则 Go 编译器会报错。在启动了多个 Goroutine（Go 语言的轻量级用户线程，后面我们会详细讲解）的 Go 应用中，main.main 函数将在 Go 应用的主 Goroutine 中执行， main 函数返回就意味着整个 Go 程序的终结，而且你也不用管这个时候是否还有其他子 Goroutine 正在执行

非 main 包中自定义的 main 函数仅限于包内使用

不过对于 main 包的 main 函数来说，你还需要明确一点，就是它虽然是用户层逻辑的入口函数，但它却不一定是用户层第一个被执行的函数，Go 语言还有一个特殊函数，它就是用于进行包初始化的 init 函数，如果 main 包依赖的包中定义了 init 函数，或者是 main 包自身定义了 init 函数，那么 Go 程序在这个包初始化的时候，就会自动调用它的 init 函数，因此这些 init 函数的执行就都会发生在 main 函数之前

不过对于 init 函数来说，我们还需要注意一点，就是在 Go 程序中我们不能手工显式地调用 init，否则就会收到编译错误

在初始化 Go 包时，Go 会按照一定的次序，逐一、顺序地调用这个包的 init 函数。一般来说，先传递给 Go 编译器的源文件中的 init 函数，会先被执行；而同一个源文件中的多个 init 函数，会按声明顺序依次执行

 Go 包的初始化次序

![go-package-init-order](https://github.com/xiaoyuge/Tech-Notes/blob/main/Go/Go/resources/go-package-init-order.jpg)

- 首先，main 包依赖 pkg1 和 pkg4 两个包，所以第一步，Go 会根据包导入的顺序，先去初始化 main 包的第一个依赖包 pkg1;

- 第二步，Go 在进行包初始化的过程中，会**采用“深度优先”的原则，递归初始化各个包的依赖包**。在上图里，pkg1 包依赖 pkg2 包，pkg2 包依赖 pkg3 包，pkg3 没有依赖包，于是 Go 在 pkg3 包中按照“常量 -> 变量 -> init 函数”的顺序先对 pkg3 包进行初始化；

- 紧接着，在 pkg3 包初始化完毕后，Go 会回到 pkg2 包并对 pkg2 包进行初始化，接下来再回到 pkg1 包并对 pkg1 包进行初始化。在调用完 pkg1 包的 init 函数后，Go 就完成了 main 包的第一个依赖包 pkg1 的初始化。
接下来，Go 会初始化 main 包的第二个依赖包 pkg4，pkg4 包的初始化过程与 pkg1 包类似，也是先初始化它的依赖包 pkg5，然后再初始化自身；

- 然后，当 Go 初始化完 pkg4 包后也就完成了对 main 包所有依赖包的初始化，接下来初始化 main 包自身;

- 最后，在 main 包中，Go 同样会按照“常量 -> 变量 -> init 函数”的顺序进行初始化，执行完这些初始化工作后才正式进入程序的入口函数 main 函数。

总结一下既是：
* 依赖包按“深度优先”的次序进行初始化；
* 每个包内按以“常量 -> 变量 -> init 函数”的顺序进行初始化；
* 包内的多个 init 函数按出现次序进行自动调用；

### **Go 的并发方案：goroutine**
Go 并没有使用操作系统线程作为承载分解后的代码片段（模块）的基本执行单元，而是实现了goroutine这一由 Go 运行时（runtime）负责调度的、轻量的用户级线程，为并发程序设计提供原生支持

相比传统操作系统线程来说，goroutine 的优势主要是：
* 资源占用小：每个 goroutine 的初始栈大小仅为 2k；
* 由 Go 运行时而不是操作系统调度：goroutine 上下文切换在用户层完成，开销更小；
* 在语言层面而不是通过标准库提供：goroutine 由go关键字创建，一退出就会被回收或销毁，开发体验更佳；
* 语言内置 channel 作为 goroutine 间通信原语，为并发设计提供了强大支撑；

和传统编程语言不同的是，Go 语言是面向并发而生的，所以，在程序的结构设计阶段，Go 的惯例是优先考虑并发设计。这样做的目的更多是考虑随着外界环境的变化，通过并发设计的 Go 应用可以更好地、更自然地适应规模化（scale）

创建 goroutine 后，go 关键字不会返回 goroutine id 之类的唯一标识 goroutine 的 id，你也不要尝试去得到这样的 id 并依赖它。另外，和线程一样，一个应用内部启动的所有 goroutine 共享进程空间的资源，如果多个 goroutine 访问同一块内存数据，将会存在竞争，我们需要进行 goroutine 间的同步

多数情况下，我们不需要考虑对 goroutine 的退出进行控制：goroutine 的执行函数的返回，就意味着 goroutine 退出。如果 main goroutine 退出了，那么也意味着整个应用程序的退出。

此外，你还要注意的是，goroutine 执行的函数或方法即便有返回值，Go 也会忽略这些返回值。所以，如果你要获取 goroutine 执行后的返回值，你需要另行考虑其他方法，比如通过 goroutine 间的通信来实现。

### **goroutine间的通信**
传统的编程语言（比如：C++、Java、Python 等）并非面向并发而生的，所以他们面对并发的逻辑多是基于操作系统的线程。并发的执行单元（线程）之间的通信，利用的也是操作系统提供的线程或进程间通信的原语，比如：共享内存、信号（signal）、管道（pipe）、消息队列、套接字（socket）等。

在这些通信原语中，使用最多、最广泛的（也是最高效的）是结合了线程同步原语（比如：锁以及更为低级的原子操作）的共享内存方式，因此，我们可以说传统语言的并发模型是基于对内存的共享的。

传统的基于共享内存的并发模型很难用，且易错，尤其是在大型或复杂程序中，开发人员在设计并发程序时，需要根据线程模型对程序进行建模，同时规划线程之间的通信方式。如果选择的是高效的基于共享内存的机制，那么他们还要花费大量心思设计线程间的同步机制，并且在设计同步机制的时候，还要考虑多线程间复杂的内存管理，以及如何防止死锁等情况

这种情况下，开发人员承受着巨大的心智负担，并且基于这类传统并发模型的程序难于编写、阅读、理解和维护。一旦程序发生问题，查找 Bug 的过程更是漫长和艰辛

Go 语言从设计伊始，就将解决上面这个传统并发模型的问题作为 Go 的一个目标，并在新并发模型设计中借鉴了著名计算机科学家Tony Hoare提出的 CSP（Communicating Sequential Processes，通信顺序进程）并发模型

![go-csp](https://github.com/xiaoyuge/Tech-Notes/blob/main/Go/Go/resources/go-csp.jpg)

Tony Hoare 的 CSP 理论中的 P，也就是“Process（进程）”，是一个抽象概念，它代表任何顺序处理逻辑的封装，它获取输入数据（或从其他 P 的输出获取），并生产出可以被其他 P 消费的输出数据

在 Go 中，与“Process”对应的是 goroutine。为了实现 CSP 并发模型中的输入和输出原语，Go 还引入了 goroutine（P）之间的通信原语channel。goroutine 可以从 channel 获取输入数据，再将处理后得到的结果数据通过 channel 输出。通过 channel 将 goroutine（P）组合连接在一起，让设计和编写大型并发系统变得更加简单和清晰，我们再也不用为那些传统共享内存并发模型中的问题而伤脑筋

虽然 CSP 模型已经成为 Go 语言支持的主流并发模型，但 Go 也支持传统的、基于共享内存的并发模型，并提供了基本的低级别同步原语（主要是 sync 包中的互斥锁、条件变量、读写锁、原子操作等）

从程序的整体结构来看，Go 始终推荐以 CSP 并发模型风格构建并发程序，尤其是在复杂的业务层面，这能提升程序的逻辑清晰度，大大降低并发设计的复杂性，并让程序更具可读性和可维护性

对于局部情况，比如涉及性能敏感的区域或需要保护的结构体数据时，我们可以使用更为高效的低级同步原语（如 mutex），保证 goroutine 对数据的同步访问

Eg.当main里面有go func的时候，如何调度执行？

1. goroutine是轻量级线程(G)，它被调度到执行器M上执行，而不是cpu上。M会被os调度到cpu上执行；
2. 可运行的G先被放入P的队列，每个P绑定一个可以用于执行G的M。之后调度程序可以从P队列中取出G放在M上执行。一个G执行一定时间后，再从队列中取出另一个G运行。 

基于上述描述，当main中通过go func启动一个新goroutine后，就会有两个可运行的(runnable)的G，新G会被放入P的队列并等待被调度。至于新G是否会与原先的main G分配到一个P上，不确定。如果机器只有一个cpu core。那么显然就如你所说的，新G与main G轮流被调度执行。如果有多个cpu core，那么新G与main G可能就是并行(paralell)执行的

### **总结### **
传统的编程语言（比如：C、C++）的并发程序设计方案是基于操作系统的线程调度模型的，这种模型与操作系统的调度强耦合，并且对于开发人员来说十分复杂，开发体验较差并且易错。

而 Go 给出的并发方案是基于轻量级线程 goroutine 的。goroutine 占用的资源非常小，创建、切换以及销毁的开销很小。并且 Go 在语法层面原生支持基于 goroutine 的并发，通过一个 go 关键字便可以轻松创建 goroutine，goroutine 占用的资源非常小，创建、切换以及销毁的开销很小。这给开发者带来极佳的开发体验




