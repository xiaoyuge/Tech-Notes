
# **前言**

这个问题被问的太多了，但很多人的答案基本千篇一律。但是有人告诉你redis的高效网络IO、单线程模型和底层数据结构的同时，会不会同时告诉你可能存在的低性能隐患以及如何避免？如果想知道，请往下看。

# **Redis为什么高性能**

Redis接收到一个键值对操作后，能以微秒级别的速度找到数据，并快速完成操作。为啥 Redis 能有这么突出的表现呢？

首先redis是内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快，但内存访问只是必要条件，还不够充分，真正让redis高性能的主要是如下两点：

## **1.高性能网络IO**

redis对网络请求的数据处理，采用的是基于epoll的IO多路复用，6.0之前是单线程处理，6.0之后优化为多线程处理，非常高效。同时对于value数据的访问也是单线程的，避免了多线程多资源竞争锁的开销和上下文切换成本；

### **Redis6.0之前版本的单线程模型**

Redis在处理客户端的请求时，包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”

Redis6.0之前版本的单线程模型为什么快？

1. 纯内存操作，时间复杂度低;
2. 单线程操作避免了频繁的线程上下文切换；
3. IO多路复用机制（通过 select、poll 、epoll 等技术实现）

### **Redis6.0版本之后的多线程模型**

在 redis 多线程模型下，包括主线程和IO线程，所谓多线程是指 IO线程并发地处理网络数据的读写和协议解析（读socke 和 回写 socket），主线程在 IO 线程读写 socket 的时候是阻塞的，在 IO线程完成 socket 读后，仍然是顺序串行的执行命令。因此，Redis6.0的多线程模型下，也不会出现线程安全问题。在多线程模型下：

1. IO线程要么同时在读 socket，要么同时在写，不会同时读或写；
2. IO线程只负责读写socket和解析命令，不负责命令执行；

![redis-6-thread-model](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/resources/redis-6-thread-model.png)

Redis6.0引入的多线程IO特性对性能的提升至少是一倍以上

### **Redis6.0之前为什么一直不使用多线程**

使用Redis时，几乎不存在CPU成为瓶颈的情况， Redis瓶颈主要受限于内存和网络。如果应用程序主要使用O(N)或O(log(N))的命令，它几乎不会占用太多CPU。使用了单线程可维护性高。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程上下文切换、甚至加锁解锁、死锁造成的性能损耗

Redis单线程模型下的性能瓶颈主要包括2个方面：

1. 任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。耗时的操作包括以下几种：
    - 操作bigkey：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时；如果下面两种情况，我就会认为它是bigkey。
        - 字符串类型：它的big体现在单个value值很大，一般认为超过10KB就是bigkey
        - 非字符串类型：哈希、列表、集合、有序集合，它们的big体现在元素个数太多
    - 使用复杂度过高的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据；
    - 大量key集中过期：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；
    - 淘汰策略：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；
    - AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能；
    - 主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；
2. 并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核;

针对问题1：一方面需要业务人员去规避，一方面Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响

针对问题2：Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的

## **2.高效数据结构**

其次要归功于它的底层数据结构。这是因为，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是 Redis 快速处理数据的基础。

为什么说高效的数据结构是Redis快速处理数据的基础?

### **高效的全局哈希**

首先，为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。这也就是说，不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针

![global-hash-table](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/resources/global-hash-table.png)

因为这个哈希表保存了所有的键值对，所以，我也把它称为**全局哈希表**。哈希表的最大好处很明显，就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素

### **高效的底层数据结构**

其次，redis的每个数据结构对对应有多个底层数据结构来实现，集合数据元素大小和数量较少的情况下，默认采用内存紧凑排列的方式存储（如数组、压缩列表），同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率，比如

- Hash：压缩列表（O（n）） -> 字典 （O（1））
- Set：整数数组（O（n）） -> 字典（O（1））
- ZSet：压缩列表（O（n）） -> 跳表（Ologn） + 字典（O（1））
- List：压缩列表（O（n）） -> 双向链表（（O（n）））

所以，如上转换后的数据结构，只有List无论是转换前的压缩列表O（n）还是转换后的双向链表O（n）的时间复杂度比较高，所以如果**对双向链表做范围查找或随机查找应该尽量避免**。

但因为压缩列表和双向链表的数据结构，可以快速查找头节点和尾节点的位置以及元素的个数，所以**对头部或尾部进行操作或获取统计值，会是O（1）的操作非常高效**。

不同底层数据结构的查找时间复杂度

![bottom-data-struct-time-complexity](https://github.com/xiaoyuge/Tech-Notes/blob/main/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/resources/bottom-data-struct-time-complexity.png)

不同操作的时间复杂度

- **单元素操作**：是指每一种集合类型对单个数据实现的增删改查操作。例如，Hash 类型的 HGET、HSET 和 HDEL，Set 类型的 SADD、SREM、SRANDMEMBER 等。这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET 和 HDEL 是对哈希表做操作，所以它们的复杂度都是 O(1)；Set 类型用哈希表作为底层数据结构时，它的 SADD、SREM、SRANDMEMBER 复杂度也是 O(1)。这里，有个地方你需要注意一下，集合类型支持同时对多个元素进行增删改查，例如 Hash 类型的 HMGET 和 HMSET，Set 类型的 SADD 也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET 增加 M 个元素时，复杂度就从 O(1) 变成 O(M) 了;

- **范围操作**：是指集合类型中的遍历操作，可以返回集合中的所有数据，比如 Hash 类型的 HGETALL 和 Set 类型的 SMEMBERS，或者返回一个范围内的部分数据，比如 List 类型的 LRANGE 和 ZSet 类型的 ZRANGE。这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免。不过，Redis 从 2.8 版本开始提供了 SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN），这类操作实现了渐进式遍历，每次只返回有限数量的数据。这样一来，相比于 HGETALL、SMEMBERS 这类操作来说，就避免了一次性返回所有元素而导致的 Redis 阻塞；

- **统计操作**：是指集合类型对集合中所有元素个数的记录，例如 LLEN 和 SCARD。这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作；

- **例外情况**：是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作；

所以，Redis 之所以能快速操作键值对，一方面是因为 O(1) 复杂度的哈希表被广泛使用，包括 String、Hash 和 Set，它们的操作复杂度基本由哈希表决定，另一方面，Sorted Set 也采用了 O(logN) 复杂度的跳表。不过，集合类型的范围操作，因为要遍历底层数据结构，复杂度通常是 O(N)

当然，我们不能忘了复杂度较高的 List 类型，它的两种底层实现结构：双向链表和压缩列表的操作复杂度都是 O(N)。因此，我的建议是：因地制宜地使用 List 类型。例如，既然它的 POP/PUSH 效率很高，那么就将它主要用于 FIFO 队列场景，而不是作为一个可以随机读写的集合

