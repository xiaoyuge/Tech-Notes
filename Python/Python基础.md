## **Python基础**

### **编译or解释**
Python语言是先编译再解释的语言。Python 在解释源程序时分为两步：
1. 将源码转为字节码
2. 将字节码转换为机器码
pyc 文件是由 Python 解释器将模块的源码转换为字节码

#### **__pyc__文件**
当我们的python文件被编译过，文件之间存在import关系，就会生成一个__pyc__文件夹

主要意义是加快启动速度。当我们的程序没有修改过，那么下次运行程序的时候，就可以跳过从源码到字节码的过程，直接加载 pyc 文件
1. import过的文件才会自动生成 pyc文件。
2. pyc文件不可以直接看到源码，可以被反编译
3. pyc的内容，是跟python的版本相关的，不同 版本编译后的pyc文件是不同的，2.5编译的pyc文件，2.4版本的python是无法执行的

备注：pyc文件是一种二进制文件，是一种跨平台的字节码，由python的虚拟机来执行的


### **应用场景**：
数据处理和分析、服务端（如web开发）开发、人工智能（如机器学习）

### **典型产品**：
Tensorflow

### **开发体验**：
语法简洁,开发效率高

### **运行效率（性能）**
不够好，原因之一是跟其是解释型语言有关，其二是其多线程对多核处理器的资源使用能力不佳，虽然 Python 确实具有线程功能，但却只能使用单一核心

### **并发编程**：
1. 使用threading库进行多线程编程时，因为GIL（全局解释器锁）的存在，同一时间只会有一个获得了 GIL 的线程在跑，其它的线程都处于等待状态等着 GIL 的释放，导致不能利用CPU物理多核的性能加速运算；
2. Python 在 2.6 里引入了 multiprocessing这个多进程标准库，让多进程的 python 程序编写简化到类似多线程的程度，大大减轻了 GIL 带来的不能利用多核的尴尬；
3. 但多进程的方案太重，还有个方案是把关键部分用 C/C++ 写成 Python 扩展，其它部分还是用 Python 来写，让 Python 的归 Python，C 的归 C。一般计算密集性的程序都会用 C 代码编写并通过扩展的方式集成到 Python 脚本里（如 NumPy 模块）。在扩展里就完全可以用 C 创建原生线程，而且不用锁 GIL，充分利用 CPU 的计算资源了；








垃圾回收：python是带GC的

库和框架：

可移植性强

基础语法：
变量赋值
数据类型
数据结构
流程控制（条件循环）
函数（方法）定义
错误和异常处理
模块
代码目录结构


